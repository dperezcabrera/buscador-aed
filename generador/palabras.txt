<html> <head> <p_align="center"> <font> </font> Ser estudiados como herramientas prácticas para la resolución de
problemas en la transformación de un problema de interés en un problema sobre grafos. <br>
<p_align="center"><font_size="3"_face="Arial,Helvetica"> <table> Algoritmos y Estructuras de Datos Ingeniería en
Informática, Curso 2º, Año 2003/2004 3.  Gestión dinámica de memoria 4.  Otras funciones de interés Ejercicios 1.
Funciones de entrada/salida "   Escribir por pantalla: printf printf ( <cadena> ); printf ( <cadena con formato>,
<expresión 1>, <expresión 2>, ...); printf("¡Buenos días!"); printf("Un entero: %d y un real: %f\n", 27*12,
3.1416); "   Especificación de formato en printf: % [flags] [width] [.prec] [F|N|h|l|L] caracter_tipo " Caracteres
de tipo: d, i (decimal), o (octal), u (unsigned), x, X (hexadecimal), f (float con la forma [-]dddd.dddd), e, E,
(float con la forma [-]d.dddd e[+/-]ddd), g, G (float "inteligente"), c (char), s (string), p (puntero). "
sprintf. Igual que printf, pero en lugar de escribir en pantalla escribe el resultado en una cadena (el primer
parámetro). char resultado[100]; sprintf(resultado, "Probando sprintf con el número %u.\n", -1);
printf(resultado); "   Leer de teclado: scanf Formato parecido a la función printf. int scanf ( <cadena con
huecos>, &<variable1>, &<variable2>, ...); int i, j, n; float r; char cadena[20]; n= scanf("%d", &i);       Lee de
teclado un entero y lo guarda en i n= scanf("%d  %f", &j, &r);   Lee un entero (en j) y un real (en r) n=
scanf("%s", cadena);           Lee una cadena (hasta el primer espacio) El valor devuelto por scanf indica el
número de huecos leídos. Los especificadores de formato son los mismos que para printf. "   sscanf. El equivalente
a scanf, pero en lugar de leer de teclado lee los caracteres de una cadena (el primer parámetro). char
entrada_simulada[100]= " 26  88.3  92"; int a, b; float g; sscanf(entrada_simulada, "%d %f %d", &a, &g, &b); "
putchar(char c). Escribe un carácter por pantalla. Equivale a: printf("%c", c) "   char getchar(void). Lee un
carácter de teclado. Equivale a: (scanf("%c", &c), c) "   Ejemplo. #include <stdio.h> main() { int i, n; float f;
char cadena[30]; printf("Introduce un entero, un float y una cadena:"); /* Probar distintas posibilidades en la
siguiente línea */ n= scanf("%d %f %s", &i, &f, cadena); /* Adaptando también este printf, claro */ printf("Huecos
leídos: %d\nValores: %d, %f, %s \n", n, i, f, cadena); } "   Ojo: normalmente la salida estándar es la pantalla y
la entrada estándar el teclado. Pero se puede utilizar redirección de entrada y salida.
>> gcc ejer1.c -o ejer1.out   Compilamos el programa de ejemplo
>> ./ejer1.out                Ejecutamos. E/S: teclado/pantalla >> ./ejer1.out > res.txt          Ahora la salida
va al fichero res.txt
>> ./ejer1.out < in.txt       Aquí la entrada está en el fichero in.txt
>> ./ejer1.out >res.txt <in.txt
La entrada estándar, salida estándar y salida de error estándar también se pueden manejar como ficheros (con los
nombres stdin, stdout y stderr) con las funciones que veremos a continuación. 2. Manejo de ficheros "   Los tipos
y funciones necesarios para el manejo de ficheros están definidos en la librería stdio.h. "   La librería stdio.h
define el tipo FILE (ojo, en mayúsculas). Para usar ficheros debemos usar punteros al tipo FILE. #include
<sdtio.h> FILE *f, *g; "   Operaciones con ficheros: o   Abrir un fichero: fopen o   Leer/escribir en un fichero:
fprintf, fscanf, getc, putc, fgets, fputs, fread, fwrite o   Moverse a un punto: fseek o   Comprobar si se ha
llegado al final: feof o   Cerrar un fichero: fclose "   Abrir un fichero: fopen FILE * fopen ( char *nombre ,
char *modo ) o   Valor devuelto: devuelve un puntero al fichero abierto. Si no se puede abrir devuelve NULL. o
Modo de acceso: de tipo cadena Fichero de texto    Fichero binario Abrir sólo lectura  "r" "rb" Crear y abrir para
escritura    "w" "wb" Abrir para añadir al final  "a" "ab" Abrir para lectura/escritura    "r+"    "r+b" Crear y
abrir para lectura/escritura    "w+"    "w+b" Abrir o crear para añadir   "a+"    "a+b" "   Cerrar un fichero:
fclose int fclose ( FILE *fichero ) "   Leer/escribir en un fichero. "   fprintf, fscanf. Igual que printf y scanf
pero en un fichero, que se pasa como primer parámetro. FILE *f; int n; f= fopen("prueba", "r+"); if (!f)
{printf("Error. No puedo..."); return;} fprintf(f, "Hola número %d", n); fscanf(f, "%d", &n); "   fgetc(FILE *f),
fputc(int c, FILE *f). Leer o escribir un carácter en un fichero. Devuelven la constante EOF si hay un error. char
c; while ((c= fgetc(f))!= EOF) printf("Leído: %c\n", c); "   fgets, fputs. Leer o escribir una línea de texto de
un fichero. Recordar que scanf("%s", ...) lee una cadena pero acabando en el primer espacio en blanco (tabulador,
intro o espacio). int fputs (char *cadena, FILE *fichero) Escribe la cadena cadena hasta el final de la misma
(carácter '\0'). Devuelve EOF si ha ocurrido un error. char *fgets (char *cadena, int max, FILE *fichero) Lee la
siguiente línea del fichero en cadena, acabando en un final de línea (carácter '\n'). Devuelve NULL si ha ocurrido
un error. "   fread, fwrite. Leer o escribir en un fichero en modo binario. unsigned fread(void *ptr, unsigned
size, unsigned n, FILE *fichero) Lee del fichero un bloque de size*n bytes y los almacena a partir de la posición
apuntada por ptr. Se supone que size es el tamaño del tipo de datos a leer y n el número de datos. Devuelve el
número de datos leídos (si no hay error, debería ser igual a n). unsigned fwrite(void *ptr, unsigned size,
unsigned n, FILE *fichero) Escribe en el fichero un bloque de size*n bytes, que se encuentran a partir de la
posición apuntada por ptr. Se supone que size es el tamaño del tipo de datos a escribir y n el número de datos.
Devuelve el número de datos escritos (si no hay error, debería ser igual a n). "   fseek. Moverse a un punto
concreto de un fichero. int fseek(FILE *fichero, long offset, int modo) Permite moverse a una posición cualquiera
dentro de un fichero. La posición nueva está dada por offset (desplazamiento, en bytes) a partir de la posición
dada por modo: SEEK_SET (=0) desde el comienzo del fichero; SEEK_CUR (=1) desde la posición actual; SEEK_END (=2)
desde el final del fichero. Función de consulta: long int ftell (FILE *fichero). "   feof. Comprobar si se ha
llegado al final de un fichero. int feof(FILE *fichero) Devuelve true (valor distinto de 0) si hemos llegado al
final del fichero o false (valor 0) en caso contrario. "   Ejemplo. #include <stdio.h> #include <stdlib.h>    /*
Función random() */ int main() { FILE *e, *s; int n, m, total= 0; if (!(e= fopen("ejemplo.txt", "w"))) {
printf("Error. No se puede crear ejemplo.txt\n"); return 1; } randomize(); fprintf(e, "%d %d\n", random(8),
random(4)); if (fclose(e)==EOF) { printf("Error. No se puede cerrar ejemplo.txt\n"); return 2; } if (!(s=
fopen("ejemplo.txt", "r"))) { printf("Error. No se puede abrir ejemplo.txt\n"); return 3; } while (!feof(s)) {
total++; if (fscanf(s, "%d %d\n", &n, &m)==2) printf("R. Murcia: %d - At. Madrid: %d\n", n, m); else printf("El
fichero no tiene el formato esperado\n"); } printf("Realizados %d pronósticos.\n", total); if (fclose(s)==EOF) {
printf("Error. No se cerrar el fichero ejemplo.txt\n"); return 4; } return 0; } "   Probar distintas posibilidades
en la línea señalada por:        , en lugar de "w" poner "a", "r", "r+", "w+", ... ¿Cuál es el resultado? nulo. En
un árbol B, con un $p$ suficientemente grande, la proporción está en torno a un puntero por clave. Por contra, en
el peor caso los nodos estarán medio vacíos. Consideremos que una entrada (clave y valor) ocupa $k_1$ bytes y un
puntero $k_2$ bytes. Un árbol AVL necesitará siempre $n (k_1+2 k_2)$ bytes, para almacenar $n$ entradas. Por otro
lado, de forma aproximada, el árbol B suponiendo que sólo se ocupan los nodos hasta la mitad, ocuparía
$2n(k_1+k_2)$. Si los nodos se llenan con más proporción, el tamaño tendería a $n(k_1+k_2)$. En definitiva, según
el porcentaje de llenado de los nodos la utilización de memoria será más o menos eficiente. 3. Gestión dinámica de
memoria "   Se puede reservar memoria en tiempo de ejecución. Las funciones para reserva de memoria están en:
stdlib.h "   Toda la memoria reservada debe ser liberada antes de acabar. Es decir, no hay liberación automática
de memoria. "   El manejo de memoria dinámica se hace usando punteros. int *arrayDimanico; float **matrizDinamica=
NULL; SEMINARIO DE C Sesión 3 Contenidos: 1.  Funciones de entrada/salida 2.  Manejo de ficheros "   Reserva de
memoria: malloc void * malloc (unsigned tamano) o   Reserva tamano bytes de memoria y devuelve un puntero a la
zona reservada. arrayDinamico = (int *) malloc (100*sizeof(int)); o   Devuelve NULL si no se ha podido reservar
esa cantidad. o   No se inicializa la memoria. " Reserva e inicialización de memoria: calloc void * calloc
(unsigned ndatos, unsigned size) o   Reserva ndatos*size bytes de memoria y devuelve un puntero a la zona
reservada. Se supone que size es el tamaño del tipo de datos a escribir y ndatos el número de datos. arrayDinamico
= (int *) calloc (100, sizeof(int)); o   Devuelve NULL si no se ha podido reservar esa cantidad. o   Se inicializa
la memoria reservada con 0. "   Relocalizar de memoria: realloc void * realloc (void *ptr, unsigned tamano) o
Redimensiona la cantidad de memoria reservada previamente a la nueva cantidad de bytes dada en tamano. "   Liberar
memoria: free void free(void *ptr) o   Libera una zona de memoria reservada previamente. No usar si ptr == NULL. "
Ejemplo. #include <stdio.h> #include <stdlib.h> char *memoria= NULL; int main() { char c; long i, tam= 0; do {
tam+= 1000000; memoria= (char *) malloc (tam); if (!memoria) { printf("Error. Imposible reservar más memoria.\n");
return 0; } printf("Reservados %ld bytes...\n", tam); for (i= 0; i<tam; i++) memoria[i]= (char) i; printf("Pulse s
para seguir saturando la máquina.\n"); while ((c= getchar())=='\n'); free(memoria); } while (c=='s' || c=='S');
return 0; } "   Otro ejemplo: páginas 310 y 311 del texto guía. 4. Otras funciones de interés "   Con cadenas:
string.h   stdlib.h Nombre  Sintaxis    Explicación strlen  unsigned strlen(char *s)    Devuelve la longitud de la
cadena. strcpy  char *strcpy(char *des, char *src) Copia la cadena src en des y devuelve des. strcat  char
*strcat(char *des, char *src)  Concatena a des la cadena src y devuelve des. strcmp  int strcmp(char *s1, char
*s2)  Compara las dos cadenas. El resultado es: 0 si son iguales; <0 si s1<s2 ; y >0 si s1>s2. atoi    int
atoi(char *s)   Convierte una cadena a un entero. Otras funciones relacionadas: atol, atof, itoa, itol, ... " Con
memoria: mem.h  string.h Nombre  Sintaxis Explicación memcpy  void *memcpy(void *dest, void *src , unsigned n)
Copia n bytes desde la posición apuntada por src hasta la apuntada por dest. Ver también memmove. memcmp  void
*memcmp(void *s1, void *s2 , unsigned n)    Compara n bytes de s1 y de s2. El resultado es como en strcmp. memset
void *memset(void *s, int c, unsigned n)   Escribe en los n bytes de s el valor (byte) c. "   Con caracteres:
ctype.h Nombre  Sintaxis    Explicación isalpha int isalpha(int c)  Devuelve true si el carácter c es una letra.
isupper int isupper(int c)  Devuelve true si el carácter c es una letra mayúscula. islower int isulower(int c)
Devuelve true Ejercicios 1.  Buscar en la ayuda (man) el significado y la sintaxis de las siguientes operaciones,
y las librerías donde se encuentran: a)  findfirst b)  findnext c)  setftime d) getftime e)  execl 2.  Escribe un
procedimiento que reserve memoria para una matriz de reales de tamaño a b, y otro que multiplique dos matrices de
dimensiones compatibles. 3.  Usando el procedimiento anterior, escribe un programa que multiplique dos matrices A
y B leídas de ficheros, la primera de tamaño n m y la segunda de tamaño m p. Las matrices deben leerse cada una de
un fichero distinto y el resultado debe estar en otro fichero. El formato del fichero es el siguiente: en la
primera línea habrán 2 enteros, indicando el tamaño de la matriz en cada dimensión. A continuación vienen las
filas de la matriz, cada una en una misma línea. Los valores son números reales. El resultado debe estar en otro
fichero con el mismo formato. Por ejemplo, un fichero de definición de una matríz podría ser el siguiente: 3 4 1
0.1  0    1.2 0    1.2  3.4  0.3 2.8  2.4  5.3  5.2 Los nombres de los ficheros serán los argumentos del programa
o (si no existen) se solicitarán a través del teclado. <title>Definiciones y terminología de grafos} En los dos
capítulos  representación de conjuntos y los diccionarios. Un conjunto, o un diccionario, contienen una colección
de relevante para el problema que los objetos por separado. En esos casos, surge de forma natural el tipo de datos
abstracto <br>{grafo}. Vamos a verlo con algunos ejemplos de </table> elementos independientes entre sí. Pero en
muchas aplicaciones existe cierta relación entre los objetos que interesa modelar; y no sólo eso, sino que la
relación resulta más problemas. <p> <body>{tabular}{p{0.007 \textwidth} p{0.955 \textwidth}} a) & <br>{Mapa de
carreteras.} Una agencia de transportes dispone de una flota de camiones, que distribuyen pimientos a nivel
nacional. Se necesita almacenar un plano de carreteras con rutas y distancias entre ciudades, para conocer los
caminos más cortos.\\ b) & <br>{Planificación de tareas.} En el proyecto de construir una pirámide hay 12.000
tareas involucradas. Existen precedencias: algunas tareas deben hacerse antes que otras. Necesitamos planificar
las tareas para tardar el menor tiempo total posible.\\ c) & <br>{Equipo de fútbol.} Un entrenador quiere ganar la
liga a toda costa. Para ello, estudiamos los rivales analizando la circulación del balón entre los jugadores. El
objetivo es encontrar cuál es el jugador clave del equipo rival, para intentar anularlo.\\ d) & <br>{Autómata
finito.} Representamos expresiones regulares mediante autómatas finitos deterministas. El autómata tiene un
conjunto de estados y transiciones entre estados. El objetivo es, dada una entrada, ver si es una expresión válida
del autómata. </body>{tabular} ¿Cuál es la relación entre las cuatro aplicaciones anteriores? En principio,
ninguna. Pero veamos las representaciones gráficas de los problemas en las figuras <label>{fig:grafejemplos1} y
<label>{fig:grafejemplos2}. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejemplos1.eps} </body>{center}
<form>{Representación de problemas mediante grafos. a) Mapa de carreteras. ¿Cuál es la distancia mínima de Cádiz a
Gerona? b) Grafo de planificación de tareas. El número indica los meses que requiere la tarea. ¿En cuánto tiempo
se puede construir la pirámide?} <meta>{fig:grafejemplos1} </body>{figure} Si analizamos detenidamente la
información manejada por los cuatro problemas, encontramos las dos similitudes clave: en todos ellos tenemos un
conjunto de elementos --que pueden ser ciudades, tareas, jugadores o estados - y relaciones entre esos elementos
--caminos entre ciudades, precedencias entre tareas, pases entre jugadores o transiciones entre estados--. Así
que, moviéndonos hacia un nivel de abstracción superior, tenemos un nuevo tipo abstracto de datos, formado por dos
clases de componentes: objetos y relaciones entre los mismos. A este tipo lo llamamos <br>{grafo}.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejemplos2.eps} </body>{center} <form>{Representación de
problemas mediante grafos. c) Estrategias de pase del balón de un equipo. ¿Qué jugador hay que eliminar para
descolocar al equipo? d) Autómata finito determinista. La secuencia: \textsf{abbaabba}, ¿es una expresión válida?}
<meta>{fig:grafejemplos2} </body>{figure} </head> El estudio teórico de problemas sobre grafos, de forma genérica,
nos servirá para desarrollar una serie de algoritmos que después se podrán aplicar sobre problemas de la vida
real. Por ejemplo, de los enunciados anteriores, el problema a) es un típico caso de caminos mínimos en grafos,
para el cual existen los algoritmos clásicos de Dijkstra y Floyd; el problema b) es un caso de utilización de
grafos dirigidos acíclicos, donde lo interesante es el cálculo de los caminos más largos; el problema c) está
relacionado con la conectividad en grafos, y se puede resolver buscando puntos de articulación del grafo;
finalmente, el problema d) es un caso particular de recorridos y caminos en grafos. <html>{Definición y tipos de
grafos} Una vez con la idea intuitiva de lo que es un grafo, vamos a ver la definición formal. <body>{definicion}
Un <br>{grafo} $G =(V, A)$ es un par formado por un conjunto de <br>{vértices}, <br>{nodos} o <br>{puntos}, $V$, y
un conjunto de <br>{arcos} o <br>{aristas}, $A$. Cada arista de $A$ es un par $(v, w)$, donde $v$ y $w$ pertenecen
a $V$. </body>{definicion} Por lo tanto, cuando trabajamos sobre grafos debemos definir dos cosas: 1) qué
representan los nodos, y 2) qué representan las aristas. Por ejemplo, un uso clásico de los grafos es la
representación de algoritmos mediante diagramas de flujo, como el mostrado en la figura <label>{fig:grafoflujo}.
¿Cómo se define el grafo? Pues definiendo los nodos y los arcos. Primero: los nodos representan instrucciones, o
bloques de instrucciones que se ejecutan secuencialmente. Segundo: las aristas representan el flujo de control
desde un bloque hasta otro. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/grafoflujo.eps} </body>{center}
<form>{Diagrama de flujos de un algoritmo (izquierda) y el grafo correspondiente (derecha).}
<meta>{fig:grafoflujo} </body>{figure} En algunos problemas, los nodos que componen una arista deben ser
distintos, es decir, $(v,v)$ no es considerada una arista válida. Por ejemplo, no es posible que un jugador juegue
consigo mismo, o que una tarea sea precedente de ella misma</a>{En cuyo caso, nunca se podría ejecutar, ya que la
precedencia implica que una tarea sólo puede empezar cuando haya acabado la predecesora.}. En otros casos, la
existencia de aristas del tipo $(v,v)$ puede estar permitida. Por ejemplo, en el autómata es perfectamente posible
una transición de un estado hacia sí mismo. &nbsp; {Grafos dirigidos y no dirigidos} Según cómo sean las aristas,
distinguimos dos tipos de grafos: <li> </font> <br>{Grafos no dirigidos}. Las aristas son pares no ordenados, es
decir $(v, w)=(w, v)$. </font> <br>{Grafos dirigidos} o <br>{digrafos}. Las aristas son pares ordenados, es decir
$(v, w)\neq(w, v)$. </li> Para distinguir las aristas, se suele usar la notación $<$<bold>n</bold>{v,w}$>$ en
grafos dirigidos y $(v,w)$ en grafos no dirigidos. Los grafos no dirigidos se utilizan para representar relaciones
</label>{simétricas}. Por ejemplo, las relaciones ``existe carretera entre'' y ``juega con'' son relaciones
simétricas entre ciudades y jugadores, respectivamente. Siempre que se dé en un sentido, se dará también en el
otro. Por lo tanto, los grafos de las figuras <label>{fig:grafejemplos1}a) y <label>{fig:grafejemplos2}c) son
grafos no dirigidos. Gráficamente, la arista se representa mediante una línea. <body>{center}
</tr></html>{cap5/aristand.eps} </body>{center} Los grafos no dirigidos representan relaciones no simétricas, en
la cual los nodos de una arista $<$<bold>n</bold>{v,w}$>$ desempeñan papeles distintos. Por ejemplo, las
relaciones ``$v$ precede a $w$'' y ``transición de $v$ a $w$'' son no simétricas. En el primer caso, $v$ es el
nodo antecesor y $w$ el sucesor. En el segundo caso, $v$ es el estado inicial y $w$ el estado final. En
consecuencia, los grafos de las figuras <label>{fig:grafejemplos1}b), <label>{fig:grafejemplos2}d) y
<label>{fig:grafoflujo} son grafos dirigidos. Si $<$<bold>n</bold>{v,w}$>$ es una arista de un grafo dirigido,
entonces decimos que $v$ es la <br>{cola} de la arista y $w$ es la <br>{cabeza}. Gráficamente, la arista es
representada mediante una flecha que va desde $v$ hasta $w$. <body>{center} </tr></html>{cap5/aristad.eps}
</body>{center} &nbsp; {Grafos etiquetados, no etiquetados y grafos con pesos} Normalmente, cada vértice de un
grafo lleva asociada una etiqueta; por ejemplo, en la figura <label>{fig:grafejemplos1}b) el nombre de la tarea y
el tiempo que se tarda en ejecutarla. Si también las aristas pueden estar etiquetadas, entonces hablamos de grafos
etiquetados. <body>{definicion} Un <br>{grafo etiquetado} $G=(V, A, W)$ es una tripla en la que $(V, A)$ es un
grafo, y $W$ es una función que a cada arco de $A$ le asigna una etiqueta de cierto tipo $T$, es decir, $W:
A<symbol> T$. Si $a </blockquote> A$, $W(a)$ será la etiqueta del arco. </body>{definicion} Si el tipo $T$ de las
etiquetas es un tipo numérico (naturales, enteros, reales, etc.) entonces decimos que se trata de un <br>{grafo
con pesos} o una <br>{red}. Por ejemplo, el grafo de la figura <label>{fig:grafejemplos2}d) es un grafo etiquetado
con caracteres, y el de la figura <label>{fig:grafejemplos1}a) es un grafo con pesos. <html>{Terminología de la
teoría de grafos} La terminología utilizada en teoría de grafos es bastante extensa, debido a las numerosas
aplicaciones de los grafos. Vamos a introducir algunos de los conceptos más importantes. Afortunadamente, la
mayoría de ellos representan ideas bastante intuitivas y fáciles de comprender. <body>{definicion} Dado un grafo
no dirigido $G=(V, A)$, si la arista $(v, w) </blockquote> A$, diremos que los vértices $v$ y $w$ son
<br>{adyacentes}, y que el arco $(v, w)$ es <br>{incidente} o <br>{incide} en los vértices $v$ y $w$. Si el grafo
$G=(V, A)$ es dirigido y $<$<bold>n</bold>{v,w}$> </blockquote> A$, diremos que $v$ es <br>{adyacente a} $w$, y
$w$ es <br>{adyacente de} $v$, y el arco $<$<bold>n</bold>{v,w}$>$ <br>{incide} en $w$. </body>{definicion} Por
ejemplo, en el grafo de la figura <label>{fig:grafoflujo} los nodos adyacentes a 3 son 4 y 5. Los nodos adyacente
de 3 son 2 y 7. Normalmente, el concepto de ``nodo adyacente a'' es más común que el de ``nodo adyacente de''. Es
más, al desarrollar los algoritmos sobre grafos supondremos que tenemos un iterador, que nos permite recorrer
todos los nodos adyacentes a uno dado. <body>{especi} <body>{in1} <br>{para cada} nodo <font_arial>{w} adyacente a
<font_arial>{v} <br>{hacer} <body>{in1} Acción sobre <font_arial>{w} </body>{in1} <br>{finpara} </body>{in1}
</body>{especi} <body>{problema} Sea $G$ un grafo no dirigido y conexo con $n$ vértices. Demostrar que $G$ debe
tener al menos $n-1$ arcos y que todos los grafos no dirigidos conexos con $n-1$ arcos son árboles. </table>
<body>{problema} En una aplicación que usa grafos etiquetados, queremos permitir que pueda existir más de una
arista entre dos nodos $(v, w)$. Tendríamos </blockquote>realmente lo que hemos denominado </label>{multigrafos}.
¿Cuál de las estructuras de representación de grafos se adapta más fácilmente a esta modificación? Justificar la
respuesta brevemente. </table> <body>{problema} ¿Cuáles son las claves de la demostración del funcionamiento
óptimo del algoritmo de Dijkstra? Es decir, ¿cómo se puede demostrar que siempre encuentra la solución óptima? ¿Y
para el algoritmo de Floyd? </table> <body>{problema} En el algoritmo para calcular los puntos de articulación de
un grafo no dirigido, puesto que la condición del punto 4 no se puede cumplir para los nodos hoja del árbol
abarcador en profundidad, se puede concluir que las hojas nunca serán puntos de articulación. Demostrar que esta
conclusión es cierta, sin usar las propiedades del algoritmo comentado. </table> <body>{problema} Mostrar un
ejemplo de grafo no dirigido con conectividad 3 y que tenga cinco nodos o más. ¿Cuántos nodos hay que eliminar
para desconectar el grafo? </table> <title>Referencias bibliográficas} La mayoría de los problemas y algoritmos
sobre grafos estudiados en este capítulo se pueden encontrar en \cite{AHO88}, tratados con un nivel de detalle
similar. El estudio sobre grafos es descompuesto en grafos dirigidos, capítulo 6, y no dirigidos, capítulo 7,
aunque la mayoría de los problemas se pueden aplicar sobre ambos tipos. También dentro de la bibliografía básica
se encuentra \cite{BaVa00}, aunque en este caso los problemas sobre grafos no son estudiados de forma separada
sino a lo largo de todo el libro. Para profundizar en otros problemas sobre grafos se puede utilizar bibliografía
adicional. Por ejemplo, en los capítulos del 22 al 26 de \cite{CoLR90} se tratan los grafos de forma exhaustiva.
El capítulo 26 está dedicado a los problemas de flujo en redes. En el capítulo 8 de \cite{Dro01} se tratan algunos
otros problemas, como el isomorfismo de grafos (en inglés </label>{matching}) y los ciclos hamiltonianos y de
Euler. </body>{ejercicios} Otro concepto muy importante sobre grafos son los caminos. La definición de camino es
también intuitiva. <body>{definicion} <meta>{def:caminografo} Un <br>{camino} de un vértice $u$ a $v$ en un grafo
$G=(V, A)$, es una secuencia de vértices $u, w_1, w_2, w_3,..., w_p, v$, tal que $(u, w_1), (w_1, w_2), ...,
(w_{p-1}, w_p), (w_p, v) </blockquote> A$. </body>{definicion} Es decir, el camino es un recorrido por los nodos,
moviéndose a través de las aristas del grafo. La definición es igualmente válida para grafos dirigidos y no
dirigidos. <body>{definicion} La <br>{longitud de un camino} es el número de arcos que lo forman, es decir, el
número de nodos que lo forman menos 1. </body>{definicion} Por ejemplo, en el camino de la definición
<label>{def:caminografo} la longitud del camino sería $p+1$. De forma parecida, podemos definir el coste de un
camino en los grafos con pesos. <body>{definicion} El <br>{coste de un camino} $u, w_1, w_2, w_3,..., w_p, v$, en
un grafo con pesos $G=(V,A,W)$ es la suma de los costes de los arcos que lo forman, es decir, $W(u,w_1) +
W(w_1,w_2)+ ...+ W(w_{p-1},w_p)+ W(w_p,v)$. </body>{definicion} Muchos de los conceptos fundamentales sobre grafos
están relacionados con los caminos, sus tipos, su existencia o no, etc. Por ejemplo, un camino se dice que es un
<br>{camino simple} si todos los vértices que lo constituyen, excepto quizás el primero y el último, son
diferentes. <body>{definicion}si el carácter c es una letra minúscula. isspace int isspace(int c)  Devuelve true
si el c es un espacio, tabulador o '\n'. toupper int toupper(int c)  Devuelve el carácter c en mayúsculas. tolower
int tolower(int c)  Devuelve el carácter c en minúsculas. "   Otras: stdlib.h Nombre  Sintaxis    Explicación
system  int system(char *command) Ejecuta un comando del sistema operativo. Devuelve 0 si no hay error. exit void
exit(int status)   Cierra todos los ficheros y termina la ejecución del programa, devolviendo status. Un
<br>{ciclo} en un grafo dirigido es un camino en el cual el primer vértice y el último son iguales. En el caso de
los grafos no dirigidos, se impone además la condición de que las aristas del camino sean distintas</a>{Esto se
hace para evitar, por ejemplo, que en un grafo no dirigido con solo una arista $(v,w)$, el camino: $v,w,v$ sea
considerado como un ciclo. No lo es.}. El ciclo se dice que es un <br>{ciclo simple} si, además de ser un ciclo,
es un camino simple. </body>{definicion} Por ejemplo, el grafo de la figura <label>{fig:grafoflujo} posee varios
ciclos; como por ejemplo las secuencias 3,5,7,3, y 3,4,5,7,3. El grafo de la figura <label>{fig:grafejemplos1}b)
no posee ningún ciclo, ¿por qué</a>{Resolveremos esta cuestión más adelante. Pero sería interesante plantearse qué
consecuencias supondría la existencia de un ciclo en este grafo.}? Un grafo sin ciclos se dice que es
<br>{acíclico}. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/conexo.eps} </body>{center} <form>{Grafos
conexos e inconexos. a) Grafo no dirigido no conexo. b) Grafo dirigido no fuertemente conexo. c) Grafo dirigido
fuertemente conexo.} <meta>{fig:conexo} </body>{figure} En los grafos dirigidos, al concepto de conexo se le añade
la etiqueta ``fuertemente'', ya que requiere la existencia de caminos en ambos sentidos. <body>{definicion} Un
grafo dirigido $G=(V, A)$, se dice que es un <br>{grafo fuertemente conexo} si para todo par de vértices $v, w
</blockquote> V$, existe un camino de $v$ a $w$, y de $w$ a $v$ en $G$. </body>{definicion} El grafo de la figura
<label>{fig:conexo}b) no es fuertemente conexo, y el de la figura <label>{fig:conexo}c) sí lo es. Al trabajar con
varios grafos, por ejemplo $G_1, G_2, G_3, ...$, se puede utilizar la notación $V(G_i)$, $A(G_i)$, para referirse
a los vértices y a las aristas del grafo $G_i$, respectivamente. Por ejemplo, podemos definir el concepto de
subgrafo de la siguiente forma. <body>{definicion} Un <br>{subgrafo} de un grafo $G$ es un grafo $G'$ tal que
$V(G') \subseteq V(G)$ y $A(G') \subseteq A(G)$. </body>{definicion} En la figura <label>{fig:subgrafo} se
muestran dos grafos, $G_1$ y $G_2$ y algunos subgrafos suyos. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/subgrafo.eps} </body>{center} <form>{Grafos y subgrafos. a) Grafo no dirigido $G_1$. b)-e)
Algunos subgrafos de $G_1$. f) Grafo dirigido $G_2$. g)-j) Algunos subgrafos de $G_2$.} <meta>{fig:subgrafo}
</body>{figure} Dado un grafo no conexo, dirigido o no dirigido, puede ser interesante en algunas aplicaciones
conocer sus subgrafos que son conexos. <body>{definicion} Dado un grafo $G$, los <br>{componentes conexos} de $G$
(o <br>{fuertemente conexos}, en grafos dirigidos) son todos los subgrafos conexos y maximales de $G$. La
condición de <br>{maximal} significa que es el mayor subgrafo que cumple la condición. </body>{definicion} Por
ejemplo, el grafo de la figura <label>{fig:conexo}a) tiene dos componentes conexos, uno formado por los nodos \{1,
2, 3, 4\} y otro por \{5, 6, 7, 8\}. El grafo $G_2$ de la figura <label>{fig:subgrafo} tiene dos componentes
fuertemente conexos, uno el formado por \{1, 2\} y el otro por \{3\}. <body>{definicion} Se llama <br>{grado de un
vértice} al número de arcos que inciden en él. En un grafo dirigido se distinguen: <br>{grado de entrada} de $v$,
es el número de arcos de los que $v$ es la cabeza; <br>{grado de salida} de $v$, es el número de arcos de los que
$v$ es la cola. </body>{definicion} Por ejemplo, en el grafo $G_1$ de anteriores hemos analizado estructuras dela
figura <label>{fig:subgrafo}, todos los nodos tienen grado 3, mientras que el nodo 2 del grafo $G_2$ tiene grado
de entrada 1 y de salida 2. Veremos algunos conceptos más sobre grafos, que definiremos según los vayamos
necesitando. <html>{Árboles, grafos y multigrafos} Los árboles se pueden considerar como un caso especial de
grafos. Una misma estructura arbórea, como la de la figura <label>{fig:lisarbgra}b), se puede ver al mismo tiempo
como un árbol y como un grafo. En particular, muchos autores consideran que un árbol no es más que un grafo no
dirigido y sin ciclos. Sin embargo, ambas cosas no son exactamente iguales. ¿En qué se diferencian?
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/lisarbgra.eps} </body>{center} <form>{Listas, árboles y
grafos. a) Una lista se puede interpretar como un árbol y como un grafo. b) Un árbol se puede ver como un grafo.
c),d) La relación contraria no siempre es posible, si existen ciclos.} <meta>{fig:lisarbgra} </body>{figure} La
diferencia está en la raíz. En un árbol existe un nodo destacado que desempeña el papel de raíz del árbol. En un
grafo todos los nodos tienen el mismo papel. En principio, no hay ningún nodo destacado, a menos que se indique
explícitamente. Por ejemplo, en el grafo de la figura <label>{fig:lisarbgra}b) cualquier nodo podría hacer de
raíz, no sólo el 1. Teniendo en cuenta este detalle, podemos establecer una relación entre árboles y grafos, en la
cual incluimos también las listas. Cualquier lista se puede considerar como un árbol, en el que cada nodo sólo
tiene un hijo. A su vez, cualquier árbol se puede interpretar como un grafo no dirigido y sin ciclos. A esta
relación podemos añadir, como estructura más general, los multigrafos. Un <br>{multigrafo} está compuesto por
nodos y aristas, pero puede existir más de una arista entre dos nodos. En los grafos normales y corrientes, esto
no es posible ya que $A$ es definido como un </label>{conjunto} de aristas y, por lo tanto, no se permite la
repetición. En la figura <label>{fig:multigrafo} se muestra un ejemplo de multigrafo. <body>{figure}[!ht]
<body>{center} </tr></html>{cap5/multigrafo.eps} </body>{center} <form>{Un ejemplo de multigrafo no dirigido.}
<meta>{fig:multigrafo} </body>{figure} Si $L$ es el conjunto infinito de todas las listas posibles, $A$ el de los
árboles, $G$ el de los grafos y $M$ el de los multigrafos, podemos decir que $L \subset A \subset G \subset M$.
Todos los conceptos vistos sobre grafos pueden extenderse a los multigrafos. No obstante, en la práctica, la
utilización de multigrafos no suele ser muy frecuente, ya que aportan poco interés respecto a los grafos. &nbsp;
{Grafos con nombre propio} Vamos a ver algunos casos concretos de grafos que tienen nombre propio. Por ejemplo, un
grafo se dice que es un <br>{grafo completo} si tiene el máximo número de aristas posibles. En la figura
<label>{fig:completo} se muestran dos ejemplos de grafos completos. El número máximo de aristas, que llamaremos
$a_{comp}$, dependerá del número de nodos del grafo, de si es dirigido o no, y de si permitimos aristas capaz de
usar los algoritmos del tipo $(v,v)$ o no. Supongamos que el grafo $G$ tiene $n$ nodos. Entonces, si es no
dirigido y se permiten aristas de un nodo consigo mismo: $a_{comp} = n(n+1)/2$, y si no se permiten: $a_{comp}=
n(n-1)/2$. En el caso de los grafos dirigidos, si se permite la arista $<$<bold>n</bold>{v,v}$>$ entonces:
$a_{comp}= n^2$ y en caso contrario: $a_{comp}= n(n-1)$. Según el número de aristas de un grafo, $a$, en relación
al máximo posible, $a_{comp}$, decimos informalmente que el grafo está más o menos conectado. Por ejemplo, en un
grafo completo $a=a_{comp}$ y decimos que es el más conectado posible. Un grafo donde $a \ll a_{comp}$, decimos
que está poco conectado. Este tipo de grafos con pocas aristas también se conoce como <br>{grafo escaso} o
<br>{disperso}. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/completo.eps} </body>{center} <form>{Grafos
completos y anillo. a) Grafo no dirigido completo de 6 nodos, suponiendo que no se permiten las aristas $(v,v)$.
b) Grafo dirigido completo de 4 nodos, si permitimos $(v,v)$. c) Grafo no dirigido con estructura de anillo.}
<meta>{fig:completo} </body>{figure} Un grafo se llama un <br>{anillo} si existe un ciclo simple que recorre todos
sus nodos, y no existen más aristas que las de ese ciclo. La idea es bastante intuitiva. Se puede ver un ejemplo
en la figura <label>{fig:completo}c). Un anillo es un ejemplo de grafo escaso. Un grafo $G$ se dice que es un
<br>un contexto genérico, a través de {grafo multietapa} si el conjunto de nodos se puede partir en $p$
subconjuntos disjuntos $V(G)= V_1 \cup V_2 \cup ... \cup V_p$, de forma que todas las aristas $(v,w) </blockquote>
A(G)$ son tales que si $v </blockquote> V_i$ entonces $w </blockquote> V_{i+1}$. Igual que antes, se puede
comprender mejor la definición a través de un ejemplo, el de la figura <label>{fig:multietapa}a). El concepto se
puede aplicar tanto a grafos dirigidos como no dirigidos. El valor de $p$ es llamado el número de etapas.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/multietapa.eps} </body>{center} <form>{Grafos multietapa. a)
Grafo dirigido multietapa, con 4 etapas: \{1\}, \{2,3,4\},\{5,6,7\},\{8,9\}. b) Grafo bipartito, con 2 etapas.}
<meta>{fig:multietapa} </body>{figure} Finalmente, decimos que un grafo no dirigido es <br>{bipartito} si es un
grafo multietapa con $p=2$ etapas. Es decir, el conjunto de vértices se puede descomponer en dos subconjuntos, de
manera que todas las aristas unen nodos de subconjuntos distintos. <html>{Especificación del tipo grafo} ¿Existe
el TAD grafo? Realmente no existe un único TAD grafo, sino una variedad de tipos abstractos. El hecho de que el
grafo sea dirigido o no, etiquetado o no, etc., no son cuestiones de implementación, sino que dan lugar a
diferentes abstracciones. De esta forma, podemos distinguir PesoArista, SuprimeArista, AdyacentesA, AdyacentesDe,
los siguientes TAD: grafo no dirigido no etiquetado, grafo no dirigido etiquetado, grafo no dirigido con pesos,
grafo dirigido no etiquetado, grafo dirigido etiquetado, grafo dirigido con pesos, etc. En algunos casos, puede
ser también interesante el tipo grafo dirigido acíclico, con sus variantes etiquetadas o no. Según la categoría de
grafo, tendrá sentido una clase de operaciones u otras. Por ejemplo, las operaciones para insertar, eliminar o
consultar vértices y aristas, existirán en todos los tipos de grafos. Otras operaciones, como las de cálculo de
caminos más cortos, sólo aparecerán en grafos con pesos; y los problemas de árboles de expansión de mínimo coste
sólo aparecerán en grafos no dirigidos con pesos. <body>{ejemplo} Vamos a ver como ejemplo un trozo de la
especificación informal del TAD grafo no dirigido con pesos. En los ejercicios veremos algunos ejemplos de
especificación formal algebraica del tipo grafo. </body>{ejemplo} <body>{especi} <p><br>{TAD} GrafoNDP[T:
TipoNumerico] <br>{es} Crear, InsertaNodo, ExisteNodo, SuprimeNodo, InsertaArista, ExisteArista,CaminoMinimo,
ExistenCiclos, ... <p><br>{Requiere} <body>{in1} El tipo <font_arial>{T} es un tipo numérico, que tiene operadores
de suma, comparación, cero y valor </font></a>{NULO}. </body>{in1} <p><br>{Descripción} <body>{in1} Los valores de
tipo <font_arial>{GrafoNDP[T]} son grafos no dirigidos con pesos de tipo <font_arial>{T}, y con representación
mutable. Los grafos se crean con la operación Crear. Después de esto, se pueden añadir vértices y aristas, sin
restricciones de tamaño. Existen operaciones para conocer los caminos mínimos entre dos nodos, comprobar si
existen ciclos, etc. Los nodos se referencian mediante un número entero: 1, 2, 3, etc. </body>{in1}
<p><br>{Operaciones} <body>{in1}  <quote> {Crear (<br>{sal} GrafoNDP[T])} \escalc {Devuelve un grafo nuevo, que no
contiene vértices ni aristas.}  <quote> {InsertaNodo (<br>{ent} <font_arial>{G}: GrafoNDP[T]; <font_arial>{nodo}:
entero)}escalc {Inserta el nodo <font_arial>{nodo} en el grafo <font_arial>{G}. Si ya existía no se modifica el
grafo.}  <quote> {ExisteNodo (<br>{ent} <font_arial>{G}: GrafoNDP[T]; <font_arial>{nodo}: entero; <br>{sal}
booleano)} \escalc {Devuelve <font_arial>{verdadero} si <font_arial>{nodo} es un nodo del grafo <font_arial>{G} y
<font_arial>{falso} en caso contrario.}  <quote> {SuprimeNodo (<br>{ent} <font_arial>{G}: GrafoNDP[T];
<font_arial>{nodo}: entero)} <font_arial>{nodo}) debe ser <font_arial>{verdadero}.} \esmodi {<font_arial>{G}}
\escalc {Elimina <font_arial>{nodo} del grafo <font_arial>{G}.}  <quote> {InsertaArista (<br>{ent}
<font_arial>{G}: GrafoNDP[T]; <font_arial>{v}, <font_arial>{w}: entero; <font_arial>{peso}: T)} \esrequ
{ExisteNodo(<font_arial>{G}, <font_arial>{v}) y ExisteNodo(<font_arial>{G}, <font_arial>{w}) deben ser
<font_arial>{verdadero}.} \esmodi {<font_arial>{G}} \escalc {Inserta en el grafo <font_arial>{G} la arista
(<font_arial>{v},<font_arial>{w}), con coste <font_arial>{peso}. Si ya existía la arista, se actualiza el peso.}
<quote> {ExisteArista (<br>{ent} <font_arial>{G}: GrafoNDP[T]; <font_arial>{v}, <font_arial>{w}: entero; <br>{sal}
booleano)} \escalc {Devuelve <font_arial>{verdadero} si la arista (<font_arial>{v},<font_arial>{w}) pertenece al
grafo <font_arial>{G}.}
 <quote> {PesoArista (<br>{ent} <font_arial>{G}: GrafoNDP[T]; <font_arial>{v}, <font_arial>{w}: entero; <br>{sal}
T)} \escalc {Devuelve el coste de la arista (<font_arial>{v},<font_arial>{w}), o NULO si no existe la arista.}
...... </body>{in1} <br>{Fin} GrafoNDP. </body>{especi} Un grafo es una abstracción compuesta por dos tipos de
elementos: objetos y relaciones entre los objetos. Los objetos son también llamados nodos o vértices. Las
relaciones son siempre entre dos vértices y se denominan aristas. Existe una amplia variedad de problemas que se
pueden modelar utilizando grafos, desde una red de ordenadores hasta un circuito eléctrico, con componentes y
conexiones entre los mismos. En diferentes aplicaciones surgen distintas clases de grafos: dirigidos, no
dirigidos, etiquetados, con pesos, acíclicos, etc. Afortunadamente, existen numerosos algoritmos sobre grafos, que
resuelven los problemas que aparecen con más frecuencia. Estos algoritmos sirven como herramientas en las que
apoyarnos para resolver problemas de la vida real que puedan ser descritos mediante grafos. </font> Conocer y
comprender la terminología usada en teoría de grafos, incluyendo: tipos de grafos, propiedades, conceptos y
problemas típicos sobre grafos. </font> Ser capaz de diseñar e implementar una estructura de datos para el tipo
grafo --en sus distintas variantes (dirigidos, no dirigidos, etiquetados)-- usando listas y matrices de
adyacencia. </font> Valorar críticamente las ventajas e inconvenientes de las representaciones de grafos mediante
listas y matrices de adyacencia, y su influencia en la eficiencia de los algoritmos sobre grafos. </font> Conocer
y comprender el funcionamiento de una variedad de algoritmos clásicos sobre grafos (tales como los algoritmos de
Prim, Kruskal, Dijkstra, Floyd y Warshall), razonando sobre las ideas subyacentes que aportan y analizando su
complejidad computacional. <title>Estructuras de representación de grafos} Después de estudiar la notación
utilizada en teoría de grafos, vamos a centrarnos en los dos problemas que nos incumben como programadores: la
representación de grafos y la resolución de problemas sobre grafos. Consideremos los grafos de la figura
<label>{fig:grafosrep1}. <body>{figure}[!h] <body>{center} </tr></html>{cap5/grafosrep1.eps} </body>{center}
<form>{Ejemplos de grafos. a) No dirigido. b) Dirigido. c) Dirigido y etiquetado.} <meta>{fig:grafosrep1}
</body>{figure} Los conjuntos de vértices y de arcos de los grafos $H_1$, $H_2$ y $H_3$ serían: <p>
$V(H_1)=\{1,2,3,4,5,6,7\}; ~ A(H_1)=\{(1,2),(1,3),(2,3),(2,4),(3,4),(3,6),(5,6),(6,7)\}$ <p> $V(H_2)=\{1,2,3,4\};
~ A(H_2)=\{<$1,3$>,<$1,2$>,<$3,2$>,<$2,4$>,<$4,3$>,<$4,4$>\}$ <p> $V(H_3)$=$\{1,2,3,4\};
A(H_3)$=$\{<$1,2$>,<$2,1$>,<$2,4$>,<$4,2$>,<$3,4$>,<$4,3$>,<$3,1$>,<$1,3$>\}$ En consecuencia, puesto que los
grafos no son más que pares de conjuntos --uno de vértices y otro de aristas-- podríamos representarlos usando
cualquiera de las estructuras de conjuntos vistas en los dos capítulos anteriores. Si los nodos o las aristas
pueden tener etiquetas, entonces tendríamos diccionarios en lugar de conjuntos. Sin embargo, es poco probable que
una representación que almacene todas las aristas en el mismo conjunto funcione eficientemente. En la práctica, el
diseño de la estructura de datos debe tener en cuenta el tipo de operaciones que se necesitan. De esta forma, la
estructura es construida para conseguir eficiencia en las operaciones que más interesan. En particular, las
operaciones que aparecerán típicamente serán del estilo: saber si existe una arista entre dos nodos dados,
recorrer todos los nodos adyacentes </label>{a} uno dado, los nodos adyacentes </label>{de} uno dado, etc. Vamos a
analizar las dos formas más utilizadas para representar el conjunto $A$ de aristas: mediante matrices y listas de
adyacencia. La discusión es muy similar al problema de representar </label>{relaciones muchos a muchos}, que
analizamos en el capítulo 3, en la sección 3.3.2. Las posibilidades que se plantean son esencialmente las mismas y
la mejor estructura depende de las características de cada aplicación particular. <html>{Representación con
matrices de adyacencia} Como ya discutimos en la representación de conjuntos, básicamente las dos estrategias
opuestas en el diseño de una estructura de datos son: usar representaciones estáticas o dinámicas. En el caso de
los grafos, la representación estática da lugar a la estructura de <br>{matrices de adyacencia}. Sea un grafo
$G=(V, A)$ con $n$ vértices. La matriz de adyacencia es una matriz $A$ --es decir, un array bidimensional-- de
tamaño $n \times n$, en la que cada posición $A[i,j]$ corresponde a la arista $(i,j)$. Si el grafo es no
etiquetado, entonces la matriz será de booleanos. Tendremos $A[i, j]=verdadero$ si $(i, j) </blockquote> A(G)$, y
$A[i, j]=falso$ en caso contrario. La definición del tipo sería inmediata. <body>{especi} <body>{in1} <br>{tipo}
<body>{in1} <br>{Nodo} = entero <br>{GrafoNoEtiq} = <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}] <br>{de}
booleano </body>{in1} </body>{in1} </body>{especi} En la tabla <label>{tab:matadyac1} se muestran las matrices de
adyacencia de los grafos $H_1$ y $H_2$, que aparecen en la figura <label>{fig:grafosrep1}. <body>{table}[!ht]
<body>{center} </tr></html>{cap5/matadyac1.eps} </body>{center} <form>{Matrices de adyacencia de los grafos $H_1$
y $H_2$ de la figura <label>{fig:grafosrep1}. Para simplificar, se usa 1 y 0, en lugar de
<bold>n</bold>{verdadero} y <bold>n</bold>{falso}.} <meta>{tab:matadyac1} </body>{table} Está claro que en los
grafos no dirigidos la matriz de adyacencia será siempre simétrica, con el desperdicio de memoria que ello supone.
Si fuera necesario ahorrar memoria, se podría almacenar sólo la parte de la matriz por encima de la diagonal
principal. ¿Cómo modificar la representación si tenemos grafos etiquetados? En lugar de tener matrices de
booleanos, usaríamos matrices del tipo de las etiquetas de las aristas. Si el grafo es de la forma $G=(V, A, W)$,
con $W: A <symbol>$ </font></a>{T}, la matriz de adyacencia sería de tipo </font></a>{T}. En la posición $A[i, j]$
se almacenaría el valor de la etiqueta correspondiente. <body>{especi} <body>{in1} <br>{tipo} <body>{in1}
<br>{Nodo} = entero <br>{GrafoEtiq[T]} = <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}] <br>{de} T
</body>{in1} </body>{in1} </body>{especi} El tipo </font></a>{T} debería tener un valor especial, $NULO$, de
manera que si no existe una arista $(v,w)$ entonces $A[v,w]=NULO$. En los grafos con pesos, la matriz de
adyacencia suele conocerse también como <br>{matriz de costes}. En muchas aplicaciones que usan matrices de
costes, el valor especial para una arista que no existe es un $+ </blockquote>fty$. Por ejemplo, si el grafo
representa caminos entre ciudades, el valor $+ </blockquote>fty$ indica que no existe esa carretera, por lo que el
coste de pasar por ella sería infinito. Como ejemplo, en la tabla <label>{tab:matadyac2} se muestra la
representación del grafo $H_3$ de la figura <label>{fig:grafosrep1}c). En este caso no se supone que $NULO$ sea $+
</blockquote>fty$. <body>{table}[!ht] <body>{center} </tr></html>{cap5/matadyac2.eps} </body>{center}
<form>{Matriz de adyacencia, o de costes, del grafo $H_3$ de la figura <label>{fig:grafosrep1}c). Para
simplificar, se usa ``-'', en lugar de <bold>n</bold>{NULO}.} <meta>{tab:matadyac2} </body>{table} &nbsp;
{Implementación de la operaciones} La representación con matrices de adyacencia es útil en problemas sobre grafos
en los cuales sea necesario saber si dos vértices están conectados o no. Conocer si existe una arista entre dos
nodos dados se puede comprobar de forma inmediata. <body>{especi} <br>{operación} ExisteArista (<font_arial>{G}:
GrafoNoEtiq; <font_arial>{v}, <font_arial>{w}: nodo): booleano <body>{in1} <br>{devolver}
<font_arial>{G}[<font_arial>{v}, <font_arial>{w}] </body>{in1} </body>{especi} Para recorrer los nodos adyacentes
a un nodo $v$ dado, simplemente habría que recorrer la fila correspondiente de la matriz. La implementación del
iterador: </font></a>{<br>{para cada} nodo <font_arial>{w} adyacente a <font_arial>{v} <br>{hacer} Acción sobre
<font_arial>{w}}, sería la siguiente: <body>{especi} <body>{in1} <br>{para} <font_arial>{w}:= 1, ...,
<font_arial>{n} <br>{hacer} <body>{in1} <br>{si} <font_arial>{G}[<font_arial>{v}, <font_arial>{w}] <br>{entonces}
<body>{in1} Acción sobre <font_arial>{w} </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1}
</body>{especi} De forma similar, en el caso de los grafos dirigidos, para conocer las aristas que llegan a un
nodo habría que recorrer la columna correspondiente a $v$. Por otro lado, si necesitamos conocer el número total
de arcos que hay en el grafo --o la suma de los costes de todas las aristas, en los grafos con pesos-- el
algoritmo debería recorrer completamente la matriz, tardando un $O(n^2)$. <body>{especi} <br>{operación}
SumarCostesAristas (<font_arial>{G}: GrafoEtiq[T]): T <body>{in1} <font_arial>{acum}:= 0 <br>{para}
<font_arial>{v}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{para} <font_arial>{w}:= 1, ...,
<font_arial>{n} <br>{hacer} <body>{in1} <br>{si} <font_arial>{G}[<font_arial>{v}, <font_arial>{w}] $\neq$ NULO
<br>{entonces} <body>{in1} <font_arial>{acum}:= <font_arial>{acum} + <font_arial>{G}[<font_arial>{v},
<font_arial>{w}] </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1} <br>{finpara} <br>{devolver}
<font_arial>{acum} </body>{in1} </body>{especi} Si la matriz que representa el grafo es dispersa o escasa,
entonces se desperdicia mucha memoria con este tipo de representación. Y no sólo eso, sino que el tiempo de
ejecución sólo depende del número de nodos, independientemente de que hayan más o menos aristas.
<html>{Representación con listas de adyacencia} Frente a las matrices de adyacencia, en la representación de
grafos con listas de adyacencia sólo se almacenan las aristas que pertenecen al grafo. Pero, en lugar de almacenar
todas las aristas en una lista única, se utiliza una lista para cada nodo con las aristas que salen del mismo.
Esto es lo que se conoce como la <br>{lista de adyacencia} de ese nodo. Sea un grafo $G=(V, A)$ con $n$ vértices.
Para cada vértice del grafo, $v </blockquote> V(G)$, tenemos una lista de vértices adyacentes a $v$. Suponiendo
que cada lista tiene un nodo cabecera, todos los nodos cabecera de todas las listas constituirán un array. La
definición del tipo de datos podría ser como la siguiente: <body>{especi} <body>{in1} <br>{tipo} <body>{in1}
<br>{Nodo} = entero <br>{GrafoNoEtiq} = <br>{array} [1..<font_arial>{n}] <br>{de} Lista[Nodo] </body>{in1}
</body>{in1} </body>{especi} Supongamos que el grafo tiene $n$ nodos y $a$ aristas. Si el grafo $G$ es dirigido,
necesitaremos $n$ nodos cabecera y $a$ celdas en las listas de adyacencia. Si es no dirigido, entonces el número
de celdas en las listas será el doble, $2a$, ya que cada arista $(v,w)$ es representada dos veces: en la lista de
$v$ y en la $w$. En la figura <label>{fig:listasady1} se muestra la representación del grafo no dirigido $H_1$ de
la figura <label>{fig:grafosrep1}, utilizando listas de adyacencia. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/listasady1.eps} </body>{center} <form>{Listas de adyacencia del grafo $H_1$ de la figura
<label>{fig:grafosrep1}a).} <meta>{fig:listasady1} </body>{figure} Si utilizamos grafos etiquetados, las listas
deben incluir también la etiqueta asociada a cada arista. Supongamos que las etiquetas son de tipo </font></a>{T}.
La definición del tipo de datos sería la siguiente: <body>{especi} <body>{in1} </body>{in1} </body>{especi} En la
figura <label>{fig:listasady2} se muestra un ejemplo de representación del grafo dirigido y con pesos, $H_3$, de
la figura <label>{fig:grafosrep1}c). <body>{figure}[!ht] <body>{center} </tr></html>{cap5/listasady2.eps}
</body>{center} <form>{Grafo dirigido con pesos y lista de adyacencia correspondiente.} <meta>{fig:listasady2}
</body>{figure} &nbsp; {Implementación de la operaciones} Utilizando listas de adyacencia, las operaciones sobre
el grafo se convierten en recorridos sobre las listas correspondientes. Por ejemplo, para consultar si existe o no
una arista entre dos nodos dados $(v,w)$, tendremos que buscar en la lista de adyacencia del nodo $v$. Supongamos
que sobre el tipo </font></a>{Lista[T]} tenemos definidas las operaciones: </font></a>{Valor}, que devuelve el
valor en una posición de la lista, y </font></a>{Siguiente}, que devuelve el siguiente nodo de la lista. La
implementación de </font></a>{ExisteArista} podría ser como la siguiente: <body>{especi} <br>{operación}
ExisteArista (<font_arial>{G}: GrafoNoEtiq; <font_arial>{v}, <font_arial>{w}: Nodo): booleano <br>{var}
<font_arial>{l}: Lista[Nodo] <body>{in1} <font_arial>{l}:= <font_arial>{G}[<font_arial>{v}] <br>{mientras}
<font_arial>{l} $\neq$ NULO <br>{hacer} <body>{in1} <br>{si} Valor(<font_arial>{l}) = <font_arial>{w}
<br>{entonces} <body>{in1} <br>{devolver} verdadero </body>{in1} <br>{finsi} <font_arial>{l}:=
Siguiente(<font_arial>{l}) </body>{in1} <br>{finmientras} <br>{devolver} falso </body>{in1} </body>{especi} De
forma similar, el iterador: </font></a>{<br>{para cada} nodo <font_arial>{w} adyacente a <font_arial>{v}
<br>{hacer} Acción sobre <font_arial>{w}}, se implementaría recorriendo la lista de adyacencia de
</font></a>{<font_arial>{v}}: <body>{especi} <body>{in1} <font_arial>{l}:= <font_arial>{G}[<font_arial>{v}]
<br>{mientras} <font_arial>{l} $\neq$ NULO <br>{hacer} <body>{in1} <font_arial>{w}:= Valor(<font_arial>{l}) Acción
sobre <font_arial>{w} <font_arial>{l}:= Siguiente(<font_arial>{l}) </body>{in1} <br>{finmientras} </body>{in1}
</body>{especi} Sin embargo, el recorrido de las aristas que llegan a un nodo sería mucho más complejo. Sería
necesario recorrer todas las listas de adyacencia de todos los nodos, y encontrar las aristas que llegan a ese
nodo. Por ejemplo, suponiendo grafos dirigidos, la operación para calcular el grado de entrada de un nodo podría
ser la siguiente: <body>{especi} <br>{operación} GradoEntrada (<font_arial>{G}: GrafoNoEtiq; <font_arial>{v}:
nodo): entero <body>{in1} <font_arial>{cuenta}:= 0 <br>{para} <font_arial>{w}:= 1, ..., <font_arial>{n}
<br>{hacer} <body>{in1} <br>{si} ExisteArista(<font_arial>{G}, <font_arial>{w}, <font_arial>{v}) <br>{entonces}
<body>{in1} <font_arial>{cuenta}:= <font_arial>{cuenta} + 1 </body>{in1} <br>{finsi} </body>{in1}
<br>{finmientras} <br>{devolver} <font_arial>{cuenta} </body>{in1} </body>{especi} Similarmente, una operación
para sumar los costes de todas las aristas del grafo debería recorrer todas las listas, acumulando los costes.
<html>{Comparación entre estructuras de representación} Como en la mayoría de los casos, según el tipo de
aplicación una estructura resultará mejor en ciertas situaciones y peor en otras. En general, las matrices de
adyacencia serán mejores cuando los grafos sean de tamaño conocido y reducido. Las listas de adyacencia serán más
adecuadas cuando los grafos puedan tener tamaño variable, y cuando tengan pocas aristas respecto al máximo
posible, es decir si son grafos </label>{escasos}. <body>{definicion} En un grafo no dirigido $G=(V, A)$, en el
que $v, w </blockquote> V$, se dice que $v$ y $w$ están <br>{conectados} si existe algún camino en el grafo $G$
que vaya desde $v$ a $w$. Esto implicaría que también existe un camino de $w$ a $v$. Un grafo no dirigido se dice
que es un <br>{grafo conectado} o <br>{conexo} si para todo par de vértices $v, w </blockquote> V$, existe un
camino de $v$ a $w$ en $G$. </body>{definicion} Por ejemplo, el grafo no dirigido de la figura
<label>{fig:conexo}a) es un grafo no conexo, compuesto por 8 nodos. &nbsp; {Utilización de memoria} Consideremos
grafos etiquetados, con $n$ nodos y $a$ aristas. Para analizar el uso de memoria, suponemos que el tamaño de un
puntero es $k_1$ bytes y el de una etiqueta $k_2$ bytes. Para no introducir más variables, tomaremos que el tamaño
de un entero es también $k_1$ bytes. Con matrices de adyacencia la memoria total ocupada sería: $k_2 n^2$ bytes,
independientemente de lo que valga $a$. Con listas de adyacencia, cada celda de la lista ocuparía $2k_1 + k_2$
bytes. En los grafos dirigidos, existe una celda por cada una de las $a$ aristas. En total tendríamos: $k_1 n +
(2k_1 + k_2)a$ bytes. En los no dirigidos las aristas están duplicadas, excepto para las que son de la forma
$(v,v)$, si se permiten. En ese caso, la memoria sería aproximadamente $k_1 n + 2(2k_1 + k_2)a$. Por lo tanto, la
comparación entre ambas estructuras depende de la relación entre $a$ y $n^2$. Si no tenemos en cuenta el término
$k_1 n$ --correspondiente a los nodos cabecera en las listas de adyacencia-- la proporción de $a/n^2$ para la cual
ambas estructuras ocupan lo mismo sería: $k_2/(2k_1 + k_2)$. Por ejemplo, si las etiquetas ocupan lo mismo que los
punteros, entonces la relación sería 1/3. Es decir, si el número de aristas del grafo es mayor que 1/3 del máximo,
la matriz de adyacencia ocuparía menos espacio; y si es menor sería mejor usar listas de adyacencia. En grafos
poco conectados o escasos, donde $a \ll n^2$, la representación con listas de adyacencia siempre sería más
adecuada. En la práctica, este tipo de grafos suelen ser más comunes. Supongamos, por ejemplo, que utilizamos
grafos para representar una red mundial de ordenadores. Digamos que el conjunto de nodos contiene unos 10.000. Sin
embargo, cada ordenador sólo está conectado directamente, por término medio, con otros 10 ordenadores. Entonces,
$a=$ 100.000, $n=$ 10.000 y la proporción $a/n^2$ sería 1/1.000. Es más, en una aplicación realista de este tipo
se deben permitir operaciones para añadir o eliminar nodos. Mientras que esto resulta fácil con listas de
adyacencia, con matrices no cabrían más nodos que el tamaño que tengamos reservado. &nbsp; {Eficiencia de las
operaciones} Vamos a estudiar comparativamente la eficiencia de las operaciones con listas y matrices de
adyacencia. Para algunas operaciones siempre será mejor usar listas, para otras será mejor con matrices y para
otras dependerá del grafo sobre el que se aplica. <li> </font> <br>{Consultar arista.} Las matrices de adyacencia
permiten un acceso muy rápido, en un $O(1)$, a una arista particular. En las listas de adyacencia es necesario
recorrer toda la lista; en el peor caso la lista será de tamaño $n$ y el tiempo un $O(n)$. En el caso promedio, la
lista sería de tamaño $a/n$ y el tiempo un $O(1+a/n)$. </font> <br>{Recorrer adyacentes.} Para recorrer los nodos
adyacentes a uno dado, con matrices de adyacencia recorríamos la fila correspondiente, tardando siempre un $O(n)$.
Con listas, el tamaño de la lista es precisamente el número de elementos que tenemos que recorrer. Igual que
antes, en el peor caso será un $O(n)$ y en promedio un $O(1+a/n)$. </font> <br>{Grado de entrada.} Cuando se trata
de conocer las aristas que llegan a un nodo, con matrices simplemente cambiamos columnas por filas. El tiempo
sería un $O(n)$. Pero con listas de adyacencia tenemos que recorrer todas las listas de todos los nodos. En total,
deberíamos comprobar $n$ nodos cabecera y $a$ nodos de las listas, con lo que el tiempo sería un $O(n+a)$. </font>
<br>{Contar todas las aristas.} El recorrido de todas las aristas supone un recorrido completo de la matriz de
adyacencia, que necesitaría un $O(n^2)$. Con listas de adyacencia, ocurre igual que con la operación anterior:
tendríamos que recorrer todas las listas de todos los nodos, tardando un $O(n+a)$. </li> En la tabla
<label>{tab:compgrafos} se resume el tiempo de ejecución y el uso de memoria para los dos tipos de
representaciones de grafos. <body>{table}[!ht] <body>{center} <body>{tabular}{|c|c|c|} \hline & Matrices de
adyacencia & Listas de adyacencia \\ \hline \hline Memoria & $k_2 n^2$ & $k_1 n + (2k_1 + k_2)a$ \\ (bytes) & & \\
\hline Consultar & $O(1)$ & $O(1+a/n)$ \\ arista & & \\ \hline Recorrer & $O(n)$ & $O(1+a/n)$ \\ adyacentes & & \\
\hline Grado de & $O(n)$ & $O(n+a)$ \\ entrada & & \\ \hline Contar las & $O(n^2)$ & $O(n+a)$ \\ aristas & & \\
\hline </body>{tabular} </body>{center} <form>{Comparación de memoria y tiempo de ejecución de algunas
operaciones, para la representación de grafos con matrices y listas de adyacencia.} <meta>{tab:compgrafos}
</body>{table} Por cuestiones de uso de memoria, la representación de listas de adyacencia se convierte en la
única alternativa viable en muchas aplicaciones. El tiempo que proporciona esta representación es bastante
``razonable'' en todas las operaciones, excepto las que necesitan conocer las aristas que llegan hasta un nodo.
¿Cómo solucionarlo? Pues, igual que tenemos en las listas de adyacencia las aristas que salen de un nodo, podemos
tener otras listas con las aristas que llegan a ese nodo. En consecuencia, tenemos una estructura de listas
múltiples, similar a las estudiadas en la sección 3.3.2. En la figura <label>{fig:listasadymult} se muestra un
ejemplo de esta estructura de representación para un grafo dirigido. Cada celda asociada a una arista $(v,w)$
pertenece a la vez a dos listas: la lista de salida de $v$ y la lista de entrada de $w$. <body>{figure}[!ht]
<body>{center} </tr></html>{cap5/listasadymult.eps} </body>{center} <form>{Grafo dirigido y etiquetado (arriba) y
estructura de listas múltiples de adyacencia asociada (abajo).} <meta>{fig:listasadymult} </body>{figure} Las
listas utilizadas son circulares. La definición del tipo sería la siguiente: <body>{especi} <body>{in1} <br>{tipo}
<body>{in1} clase\_registro = <br>{enumerado} (nodo, arista) tipo\_registro[T] = <br>{registro} <body>{in1}
<br>{según} clase: clase\_registro <body>{in1} nodo: (lista\_entrada, lista\_salida: Puntero[tipo\_registro])
Muestra el resultado de insertar los siguientes elementos en un árbol trie: patria, patriada, patriar, patriarca,
patriarcadgo, patriarcado. Elige un tipo de representación para los nodos del árbol y haz una estimación
aproximada de la memoria ocupada para este ejemplo concreto. arista: (valor: T; sig\_ent, sig\_sal:
Puntero[tipo\_registro]) </body>{in1} <br>{finsegún} </body>{in1} <br>{finregistro} <br>{Nodo} = entero
<br>{Arista[T]} = <br>{registro} <body>{in1} vert: Nodo <br>{GrafoEtiq[T]} = <br>{array} [1..<font_arial>{n}]
<br>{de} tipo\_registro[T] </body>{in1} </body>{in1} </body>{especi} grado de entrada de un nodo sería, en
promedio un $O(1+a/n)$. Como contrapartida, se necesita más memoria para los punteros de las listas. Utilizando
listas de adyacencia múltiples, el tiempo de la operación para conocer el <title>Recorridos sobre grafos}
<br>{tipo} <body>{in1} etiq: T </body>{in1} <br>{finregistro} <br>{GrafoEtiq[T]} = <br>{array}
[1..<font_arial>{n}] <br>{de} Lista[Arista[T]] </body>{in1} luego todos los adyacentes a los anteriores (es decir
los que están a distancia 2) y no visitados, luego los que están a distancia 3, y así sucesivamente hasta recorrer
todos los nodos. El recorrido de un grafo, ya sea dirigido o no dirigido, es un proceso mediante el cual se
visitan sus vértices ordenadamente, según un orden dado por las aristas. Básicamente, la idea es muy parecida al
recorrido sobre árboles; se parte de un vértice dado y sirven para visitar los vértices y los arcos de manera
sistemática, moviéndose a través de las aristas del grafo. Fundamentalmente, podemos encontrar dos tipos de
recorridos sobre grafos: En sí mismas, las operaciones de recorrido no tienen mucho interés. Si simplemente
quisiéramos procesar todos los nodos, sin importar el orden, podríamos hacerlo empezando por el 1, 2, 3, etc. La
utilidad de los recorridos es que pueden ser utilizados para resolver una amplia variedad de problemas sobre
grafos. El orden de recorrido define un <li> </font> <br>{Búsqueda primero en profundidad.} En un árbol, sería el
equivalente a un recorrido en preorden. Se elige un nodo $v$ de partida. Se marca como visitado y se recorren los
nodos no visitados adyacentes a $v$, usando recursivamente la búsqueda primero en profundidad. </font>
<br>{Búsqueda primero en amplitud o anchura.} Aplicado sobre un árbol, sería similar a recorrerlo por niveles:
primero la raíz, luego los hijos, después los nietos, etc. En un grafo, empezando por un nodo $v$, se visitan
primero todos los nodos adyacentes a $v$, </li> orden en el que se deben procesar los nodos para resolver
problemas como la búsqueda de ciclos, de puntos de articulación, de componentes fuertemente conexos, etc. Para no
pasar por un mismo vértice del grafo más de una vez, se usa un array de marcas, en las que se indica si un vértice
está visitado o no. Supondremos que este array </font></a>{marca} es una variable global. <body>{especi}
<body>{in1} <br>{var} <body>{in1} <font_arial>{marca} : <br>{array} [1..<font_arial>{n}] <br>{de} <br>{enumerado}
(visitado, noVisitado) </body>{in1} <br>{operación} BorraMarcas <body>{in1} <br>{para} <font_arial>{v}:= 1, ...,
<font_arial>{n} <br>{hacer} <body>{in1} <font_arial>{marca}[<font_arial>{v}]:= noVisitado </body>{in1}
<br>{finpara} </body>{in1} </body>{in1} </body>{especi} <html>{Búsqueda primero en profundidad}
<meta>{sec:grafosbpp} La <br>{búsqueda primero en profundidad}, como ya hemos comentado, es un proceso recursivo
equivalente al recorrido en orden previo de un árbol. Se selecciona un vértice $v$ del grafo y, para cada vértice
adyacente a $v$ no visitado, se recorre invocando recursivamente la búsqueda primero en profundidad. Los nodos
visitados se van marcando en el orden de ejecución del procedimiento recursivo. Este procedimiento es válido tanto
para grafos dirigidos como no dirigidos. La diferencia se encuentra en lo que se considere como nodo adyacente a
uno dado. La implementación de la búsqueda en profundidad sería como la siguiente: <body>{especi} <body>{in1}
<br>{operación} bpp (<font_arial>{v}: Nodo) <body>{in1} <font_arial>{marca}[<font_arial>{v}]:= visitado <br>{para
cada} nodo <font_arial>{w} adyacente a <font_arial>{v} <br>{hacer} <body>{in1} <br>{si}
<font_arial>{marca}[<font_arial>{w}] = noVisitado <br>{entonces} <body>{in1} bpp(<font_arial>{w}) </body>{in1}
<br>{finsi} </body>{in1} <br>{finpara} </body>{in1} </body>{in1} </body>{especi} En la figura <label>{fig:bpp1} se
muestra un ejemplo de la aplicación de </font></a>{bpp(<font_arial>{a})} sobre un grafo no dirigido. El orden de
recorrido de unos nodos a partir de otros se puede ver como un árbol. Es lo que se conoce como el <br>{árbol de
expansión en profundidad}. La raíz del árbol es el nodo, $a$, para el cual se hace la llamada inicial. Los
descendientes de un nodo $v$ son todos los nodos $w$ para los cuales $v$ ejecuta la llamada recursiva
</font></a>{bpp(<font_arial>{w})}. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/bpp1.eps} </body>{center}
<form>{Grafo no dirigido (izquierda) y árbol de expansión en profundidad (derecha). Los números indican el orden
en que son visitados los nodos.} <meta>{fig:bpp1} </body>{figure} Las aristas dibujadas con línea continua en la
figura <label>{fig:bpp1} son llamadas <br>{arcos del árbol}. Se puede ver que aparecen también algunas aristas
marcadas con línea discontinua. Estas aristas son los arcos que no son del árbol. Es decir, son aristas del grafo
pero que no pertenecen al árbol de expansión. La existencia de estas aristas se comprobaría cuando la condición
``</font></a>{<br>{si} <font_arial>{marca}[<font_arial>{w}] = noVisitado ...}'' es falsa. Ya que podría ocurrir
que después de realizar la llamada a </font></a>{bpp} haya vértices que aún no hayan sido visitados, el anterior
procedimiento suele aparecer dentro de otro más general, que inicia las llamadas recursivas. En definitiva, el
procedimiento de búsqueda primero en profundidad sería el siguiente: <body>{especi} <body>{in1} <br>{operación}
BusquedaPrimeroEnProfundidad <body>{in1} BorraMarcas <br>{para} <font_arial>{v}:= 1, ..., <font_arial>{n}
<br>{hacer} <body>{in1} <br>{si} <font_arial>{marca}[<font_arial>{v}] = noVisitado <br>{entonces} <body>{in1}
bpp(<font_arial>{v}) </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1} </body>{in1} </body>{especi}
En la figura <label>{fig:bpp2} se muestran dos ejemplos de recorridos en profundidad, sobre grafos dirigidos y no
dirigidos. Si el procedimiento de búsqueda primero en profundidad da lugar a varios árboles de expansión, entonces
hablamos de <br>{bosque de expansión en profundidad}. Está claro que pueden existir distintas búsquedas en
profundidad del mismo grafo. Dependiendo del nodo que visitemos en primer lugar y del orden de visita de los
adyacentes, tendremos un bosque de expansión u otro. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/bpp2.eps} </body>{center} <form>{Dos grafos (izquierda) y sus bosques de expansión en
profundidad (derecha). Los números indican el orden en que son visitados los nodos.} <meta>{fig:bpp2}
</body>{figure} &nbsp; {Arcos que no son del árbol} Tal y como se muestra en la figura <label>{fig:bpp2}, en los
grafos dirigidos podemos clasificar los arcos que no son del árbol en tres tipos: <li> </font> Los <br>{arcos de
avance} van de un vértice a otro que es descendiente del primero dentro de un árbol; en el ejemplo de la figura
<label>{fig:bpp2}, la arista $<$<bold>n</bold>{a,d}$>$. </font> Los <br>{arcos de retroceso} van de un vértice a
otro que es ascendiente del primero dentro de un árbol; en el ejemplo de la figura <label>{fig:bpp2}, la arista
$<$<bold>n</bold>{c,a}$>$. </font> Los <br>{arcos de cruce} son todos los demás; por ejemplo, las aristas
$<$<bold>n</bold>{d,c}$>$, $<$<bold>n</bold>{f,b}$>$ y la $<$<bold>n</bold>{g,d}$>$. </li> En los grafos no
dirigidos, todas las aristas son de <br>{avance/retroceso}. No puede existir un arco de cruce de $v$ a $w$, ya que
en ese caso se habría realizado la llamada recursiva para $w$ desde $v$. Los arcos que no son del árbol pueden
servir para diferentes propósitos. Por ejemplo, pueden utilizarse para realizar una <br>{prueba de aciclicidad},
es decir, dado un grafo comprobar si tiene ciclos o no. En el caso de los grafos no dirigidos, habrá un ciclo sí y
sólo si aparece algún arco que no sea del árbol. En los grafos dirigidos, tendremos un ciclo si encontramos en el
recorrido algún arco $<$<bold>n</bold>{w,v}$>$ de retroceso</a>{¿Cuál sería el ciclo? Pues movernos desde $v$ a
$w$ por las aristas del árbol, y luego desde $w$ a $v$ a través del arco de retroceso.}. <body>{ejemplo} ¿Cómo se
puede comprobar si un arco es del árbol abarcador en profundidad y, en caso de no serlo, encontrar de qué tipo es?
Para hacerlo, sería necesario construir el bosque de expansión explícitamente. En concreto, el mismo array
</font></a>{<font_arial>{marca}} se podría utilizar para almacenar un conjunto de árboles representados mediante
punteros al padre. En lugar de ser un array de booleanos, utilizaríamos un array de enteros. En cada posición
</font></a>{<font_arial>{marca}[<font_arial>{v}]}, indicamos cuál es el padre de </font></a>{<font_arial>{v}}, o
bien con un 0 que es una raíz, o un -1 para decir que no está visitado. La inicialización en
</font></a>{BorraMarcas} sería a -1, y el procedimiento </font></a>{bpp} se debería modificar del siguiente modo:
</body>{ejemplo} <body>{especi} <body>{in1} <br>{operación} bpp2 (<font_arial>{v}: Nodo) <body>{in1} <br>{si}
<font_arial>{marca}[<font_arial>{v}] = -1 <br>{entonces} <body>{in1} <font_arial>{marca}[<font_arial>{v}]:= 0 \ \
\ \ <font_arial>{// v es una raíz} </body>{in1} <br>{finsi} <br>{para cada} nodo <font_arial>{w} adyacente a
<font_arial>{v} <br>{hacer} <body>{in1} <br>{si} <font_arial>{marca}[<font_arial>{w}] = -1 <br>{entonces}
<body>{in1} <font_arial>{marca}[<font_arial>{w}]:= v \ \ \ \ <font_arial>{// v es el padre de w}
bpp2(<font_arial>{w}) </body>{in1} <br>{sino} <body>{in1} ArcoQueNoEsDelArbol(<font_arial>{v}, <font_arial>{w})
</body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1} </body>{in1} </body>{especi} En el procedimiento
</font></a>{ArcoQueNoEsDelArbol(<font_arial>{v}, <font_arial>{w})} tenemos un arco $(v,w)$ que no es del árbol,
así que habría que comprobar el caso que ocurre. Con grafos dirigidos, si $v$ es descendiente de $w$, tenemos un
arco de retroceso; si $v$ antecesor de $w$, tenemos un arco de avance; en otro caso tenemos un arco de cruce. Si
usamos grafos no dirigidos, tendremos un arco de avance/retroceso siempre que $w$ no sea el padre de $v$ en el
árbol, es decir si </font></a>{<font_arial>{marca}[<font_arial>{v}] $\neq$ <font_arial>{w}}. &nbsp; {Tiempo de
ejecución de la búsqueda en profundidad} Es difícil obtener el tiempo de ejecución de la búsqueda primero en
profundidad, si tratamos de hacer el análisis de la forma tradicional. El procedimiento realiza llamadas
recursivas, que dependen del número de adyacentes de cada nodo. Sin embargo, es posible ``darle la vuelta'' al
análisis y encontrar la solución fácilmente. La idea se conoce como analizar un algoritmo midiendo el <br>{trabajo
total realizado}. Es decir, no contamos las instrucciones según se ejecutan, sino que analizamos cuál será el
resultado final del algoritmo. En concreto, sabemos que la búsqueda en profundidad recorrerá cada nodo exactamente
una vez, así que </font></a>{bpp} se ejecutará $n$ veces en total. Para cada una de esas ejecuciones, se marca el
nodo como visitado y luego se recorren todos sus adyacentes. Ya vimos que el tiempo de recorrer los adyacentes
depende de la representación. Con matrices de adyacencia, teníamos un bucle que recorre una fila de la matriz, de
tamaño $n$. Para cada adyacente hay una comparación, que se hace en un tiempo constante. Por lo tanto, cada
ejecución de </font></a>{bpp} por sí misma tiene un $O(n)$. Multiplicando, el tiempo de ejecución de la búsqueda
en profundidad con matrices de adyacencia es un $O(n^2)$. Con listas de adyacencia, el recorrido de los adyacentes
a un nodo implica recorrer una lista. Si el grafo tiene $a$ aristas, el tamaño de cada lista es $a/n$ en promedio.
Por lo tanto, si contamos las $n$ ejecuciones de </font></a>{bpp}, tenemos que el tiempo con listas de adyacencia
es un $O(n(1+a/n)) = O(n+a)$. ¿Cuál es el trabajo total realizado? Con matrices de adyacencia, el algoritmo acaba
recorriendo toda la matriz, ya sea en una u otra llamada. Además por cada celda de la matriz tarda un tiempo
constante. De esta forma sale el $O(n^2)$ en matrices de adyacencia. En listas de adyacencia, el algoritmo siempre
recorre todas las listas de todos los nodos, gastando también un tiempo constante en cada celda. En consecuencia,
el tiempo con listas de adyacencia es proporcional al tamaño de estas listas, $O(n+a)$. <html>{Búsqueda primero en
anchura} Si la idea de la búsqueda primero en profundidad es movernos siempre lo más profundo posible,
intuitivamente, en la <br>{búsqueda primero en anchura} el recorrido se extiende a lo ancho. De esta forma, si
partimos de un nodo $v$, lo marcamos como visitado en primer lugar. Después se visitan todos los adyacentes a $v$.
A continuación los adyacentes de estos últimos que no estén ya visitados, y así sucesivamente. Para hacer el
recorrido se utiliza una cola de vértices, que al principio contendrá sólo el nodo inicial. Básicamente, el
funcionamiento de la búsqueda en anchura consiste en: sacar un elemento $v$ de la cola, añadir a la cola los
adyacentes de $v$ no visitados y acabar cuando se vacíe la cola</a>{Si nos fijamos un poco, la búsqueda en
profundidad podría interpretarse de forma parecida, pero usando una pila en lugar de una cola. Ojo, además los
nodos se deberían marcar al sacarlos de la pila, y no al meterlos.}. Igual que con la </font></a>{bpp}, hacemos
uso de un procedimiento que se ocupa de arrancar las llamadas de </font></a>{bpa} que sean necesarias. Las
operaciones serían las siguientes: <body>{especi} <body>{in1} <br>{operación} BusquedaPrimeroEnAnchura <body>{in1}
BorraMarcas <br>{para} <font_arial>{v}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{si}
<font_arial>{marca}[<font_arial>{v}] = noVisitado <br>{entonces} <body>{in1} bpa(<font_arial>{v}) </body>{in1}
<br>{finsi} </body>{in1} <br>{finpara} </body>{in1} \ \ <br>{operación} bpa (<font_arial>{v}: Nodo) <br>{var}
<font_arial>{C}: Cola[Nodo] <body>{in1} <font_arial>{marca}[<font_arial>{v}]:= visitado <font_arial>{C}:=
CrearCola Insertar(<font_arial>{C}, <font_arial>{v}) <br>{mientras} NO EsVacíaCola(<font_arial>{C}) <br>{hacer}
<body>{in1} <font_arial>{x}:= Frente(<font_arial>{C}) SuprimirCola(<font_arial>{C}) <br>{para cada} nodo
<font_arial>{w} adyacente a <font_arial>{x} <br>{hacer} <body>{in1} <br>{si} <font_arial>{marca}[<font_arial>{w}]
= noVisitado <br>{entonces} <body>{in1} <font_arial>{marca}[<font_arial>{w}]:= visitado
InsertaCola(<font_arial>{C}, <font_arial>{w}) </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1}
<br>{finmientras} </body>{in1} </body>{in1} </body>{especi} En la figura <label>{fig:bpa1} se muestra la ejecución
de la búsqueda en anchura para dos grafos. Podemos definir los <br>{árboles} y <br>{bosques de expansión en
anchura}, de forma similar a los bosques de expansión en profundidad. En este caso, un nodo $v$ es padre de $w$ en
el árbol, si la iteración de $v$ introduce a $w$ en la cola. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/bpa1.eps} </body>{center} <form>{Dos grafos (izquierda) y sus bosques de expansión en anchura
(derecha). Los números indican el orden en que son visitados los nodos.} <meta>{fig:bpa1} </body>{figure} Igual
que antes, aparecen arcos del árbol y arcos que no son del árbol. Si antes, en grafos no dirigidos, los arcos que
no son del árbol eran siempre de avance/retroceso con </font></a>{bpp}, ahora sólo aparecen arcos de cruce. Es
fácil encontrar la razón si tenemos en cuenta el funcionamiento del algoritmo. &nbsp; {Tiempo de ejecución de la
búsqueda en profundidad} El análisis del tiempo de ejecución es muy parecido al realizado para la búsqueda en
anchura. Igual que antes, no seguimos la ejecución del algoritmo sino que consideramos el trabajo total realizado.
En este caso, sabemos que cada uno de los $n$ vértices se visita una vez, se introduce en la cola exactamente una
vez, se saca de la cola una vez y se visitan todos sus adyacentes una vez. Así que el bucle
</font></a>{<br>{mientras}} se ejecuta $n$ veces. El orden de complejidad del algoritmo viene dado por el tiempo
que se necesite en recorrer todos los adyacentes. Por lo tanto, podemos decir lo mismo que en la búsqueda en
profundidad. Con matrices de adyacencia, el algoritmo acaba recorriendo toda la matriz, dando lugar a un $O(n^2)$.
Con listas de adyacencia, se recorren todas las listas, con un coste total de $O(n+a)$. <title>Árboles de
expansión de coste mínimo} Como vimos en la introducción, existe una relación entre árboles y grafos. Un grafo no
dirigido y sin ciclos se puede interpretar casi como un árbol</a>{A no ser porque el árbol tiene raíz y el grafo
no.}. De hecho, ya hemos usado el concepto de árbol de expansión de un grafo, para describir el orden de recorrido
de los nodos en la búsqueda primero en profundidad y en anchura. Podemos definir formalmente el concepto de la
siguiente forma. <body>{definicion} Un <br>{árbol de expansión} de un grafo no dirigido $G=(V, A)$ y conexo es un
subgrafo $G'=(V, A')$ no dirigido, conexo y sin ciclos. </body>{definicion} Es decir, el árbol de expansión
contiene los mismos nodos que $G$ y sigue siendo conexo, pero no tiene ciclos. En consecuencia, tiene el mínimo
número posible de aristas para mantener conexo el grafo: $n-1$, suponiendo un grafo de $n$ nodos. Si el grafo es
ponderado, podemos definir el <br>{coste de un árbol de expansión} como la suma de los costes de sus aristas. Dado
un grafo no dirigido con pesos, pueden existir muchos árboles de expansión del mismo. El <br>{problema del árbol
de expansión de coste mínimo} de un grafo $G$ consiste en encontrar, de todos los árboles de expansión de $G$,
aquel que tenga el menor coste. Vamos a analizar un caso típico de aplicación donde surge el problema.
<body>{ejemplo} Supongamos que tenemos varios ordenadores que queremos conectar en red. Hacemos un presupuesto de
lo que nos costaría cada conexión punto a punto, obteniendo el grafo de la figura <label>{fig:aecm1}. No obstante,
no todas las conexiones son necesarias, ya que dos ordenadores se pueden comunicar a través de otro. El objetivo
es seleccionar las conexiones que debemos contratar con dos requisitos: que todos los ordenadores estén
comunicados entre sí y que el coste requerido sea el mínimo. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/aecm1.eps} </body>{center} <form>{Una red de ordenadores, con posibles conexiones. Los números
de las aristas indican los costes presupuestados para cada enlace, en miles de euros.} <meta>{fig:aecm1}
</body>{figure} Tenemos un problema de árbol de expansión de coste mínimo. Los ordenadores son los nodos y las
conexiones las aristas. El resultado debe ser un árbol de expansión, para garantizar que no se usan más conexiones
de las necesarias, pero garantizando que el grafo es conexo. Y debe ser el de coste mínimo para conseguir el
segundo requisito del problema. </body>{ejemplo} Existen dos algoritmos </label>{clásicos} para encontrar el árbol
de expansión de coste mínimo de un grafo: los algoritmos de Prim y de Kruskal, conocidos así por sus autores, R.
C. Prim y J. B. Kruskal, que los propusieron a mediados del pasado siglo XX. <html>{Algoritmo de Prim} El
funcionamiento del algoritmo de Prim es bastante intuitivo. La idea es la siguiente: <li> </font> Se toma un
vértice $v$ cualquiera del grafo. Inicialmente, el árbol consta sólo de este nodo. Por ejemplo, en el grafo de la
figura <label>{fig:aecm1} digamos que cogemos el 1. </font> Se estudian los pesos de los arcos entre $v$ y todos
los demás vértices, y se escoge el menor. Ahora el árbol consta de dos vértices y la arista que los une. En el
ejemplo, cogeríamos el nodo 3, cuya arista tiene peso 1. </font> Se analizan los costes de todos los arcos que
unen cualquiera de esos dos vértices con el resto. De todos ellos se escoge el de menor coste. Ahora tenemos en el
árbol tres nodos y dos aristas. En el ejemplo, la arista de menor coste con 1 ó 3 sería la arista (3,6) o la
(1,4), ambas con coste 4. </font> De esta forma, el proceso se repite sucesivamente hasta seleccionar todos los
vértices del grafo, añadiendo en cada paso un vértice y una arista al árbol. </li> Aún antes de pasar a la
implementación, es fácil comprobar manualmente el funcionamiento del algoritmo. En la figura <label>{fig:aecm2} se
muestra un ejemplo de aplicación. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/aecm2.eps} </body>{center}
<form>{Aplicación del algoritmo de Prim. a) Grafo de entrada del algoritmo. b)-e) Pasos de aplicación del
algoritmo. f) Árbol de expansión de coste mínimo resultante.} <meta>{fig:aecm2} </body>{figure} Vemos que el
algoritmo trabaja implícitamente con dos conjuntos de vértices: los que ya hemos incorporado al árbol de expansión
y los que quedan por escoger. Sea $U$ el conjunto de los vértices ya escogidos; los que quedan por estudiar serán
$V-U$. Inicialmente, $U$ consta sólo del vértice de partida. En cada paso del algoritmo, buscamos la arista de
menor coste que vaya de un nodo en $U$ a otro en $V-U$. Informalmente, decimos que se busca el vértice de $V-U$
<br>``más cercano</a>{Notar que esto supone interpretar los </label>{costes} como </label>{distancias}.}'' a
alguno de los de $U$. El algoritmo acaba cuando hemos añadido todos los vértices a $U$, es decir, cuando $U=V$.
&nbsp; {Implementación del algoritmo de Prim} Para calcular en cada paso la arista de menor coste entre un vértice
de $U$ y otro de $V-U$ vamos a utilizar dos arrays: <li> </font> [-]
</font></a>{<font_arial>{MásCercano}[<font_arial>{v}]}, que da el vértice en $U$ que está más cercano al vértice
</font></a>{<font_arial>{v}} de $V-U$. </font> [-] </font></a>{<font_arial>{MenorCoste}[<font_arial>{v}]}, que da
el coste de la arista entre </font></a>{<font_arial>{v}} y </font></a>{<font_arial>{MásCercano}[<font_arial>{v}]}.
</li> Si empezamos por el nodo 1, entonces inicialmente el </font></a>{<font_arial>{MásCercano}} para todos los
nodos será el nodo 1, y </font></a>{<font_arial>{MenorCoste}} será el coste de las aristas de cada nodo con 1. En
cada paso del algoritmo se recorre </font></a>{<font_arial>{MenorCoste}}, hasta encontrar el vértice $k$ de $V-U$
más cercano a $U$. Se añade al árbol la arista, que será
<bold>n</bold>{(k,}</font></a>{<font_arial>{MásCercano}}<bold>n</bold>{[k])}, y se actualizan los arrays, teniendo
en cuenta que $k$ pertenece ahora a $U$ y no a $V-U$. Para simplificar, en lugar de usar el tipo grafo
trabajaremos directamente con una <br>{matriz de costes} $C$, de tamaño $n \times n$, donde $C[i, j]$ es el coste
de la arista $(i,j)$. Si no existe arista entre dos vértices, el valor de la posición correspondiente en la matriz
será suficientemente grande como para no ser tenido en cuenta en ningún momento. Denotaremos este valor con ``$+
</blockquote>fty$''. Por otro lado, el resultado viene dado en un tipo </font></a>{GrafoNDE[T]}, en el cual se
suponen operaciones para añadir nodos y aristas. En definitiva, el algoritmo de Prim sería el siguiente.
<body>{especi} <br>{operación} Prim (<font_arial>{C}: <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}]
<br>{de} real; <br>{var} <font_arial>{A}: GrafoNDE[real]) <br>{var} <body>{in1} <font_arial>{MenorCoste}:
<br>{array} [1..<font_arial>{n}] <br>{de} real <font_arial>{MásCercano}: <br>{array} [1..<font_arial>{n}] <br>{de}
entero \ \ \ \ \ \ \ <font_arial>{ // Inicialización: el conjunto U sólo contiene el vértice 1} <font_arial>{A}:=
CrearGrafo InsertaNodo(<font_arial>{A}, 1) <br>{para} <font_arial>{i}:= 2 <br>{hasta }<font_arial>{n} <br>{hacer}
<body>{in1} <font_arial>{MenorCoste}[<font_arial>{i}]:= <font_arial>{C}[1, <font_arial>{i}]
<font_arial>{MásCercano}[<font_arial>{i}] := 1 </body>{in1} <br>{finpara} \ \ \ \ \ \ \ <font_arial>{ // Repetir
n-1 veces: encuentra el vértice k de V-U más cercano a alguno de U } <br>{para} <font_arial>{i}:= 2 <br>{hasta}
<font_arial>{n} <br>{hacer} <body>{in1} <font_arial>{min}:= <font_arial>{MenorCoste}[2] \ \ \ \ <font_arial>{ //
Busca la arista con mínimo MenorCoste} <font_arial>{k}:= 2 <br>{para} <font_arial>{j}:= 3 <br>{hasta}
<font_arial>{n} <br>{hacer} <body>{in1} <br>{si} <font_arial>{MenorCoste}[<font_arial>{j}] $<$ <font_arial>{min}
<br>{entonces} <body>{in1} <font_arial>{min}:= <font_arial>{MenorCoste}[<font_arial>{j}] <font_arial>{k}:=
<font_arial>{j} </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} InsertaNodo(<font_arial>{A}, <font_arial>{k})
\ \ \ <font_arial>{ // Inserta k al árbol de expansión} InsertaArista(<font_arial>{A},
(<font_arial>{k},<font_arial>{MásCercano}[<font_arial>{k}])) MenorCoste[<font_arial>{k}]:= $+ </blockquote>fty$
<br>{para} <font_arial>{j}:= 2 <br>{hasta} <font_arial>{n} <br>{hacer} \ \ \ <font_arial>{ // Recalcular los
costes de U, tras añadir k} <body>{in1} <br>{si} (<font_arial>{C}[<font_arial>{k}, <font_arial>{j}] $<$
<font_arial>{MenorCoste}[<font_arial>{j}]) Y (<font_arial>{MenorCoste}[<font_arial>{j}] $\neq + </blockquote>fty$
) <br>{entonces} <body>{in1} <font_arial>{MenorCoste}[<font_arial>{j}]:= <font_arial>{C}[<font_arial>{k},
<font_arial>{j}] <font_arial>{MásCercano}[<font_arial>{j}]:= <font_arial>{k} </body>{in1} <br>{finsi} </body>{in1}
<br>{finpara} </body>{in1} <br>{finpara} </body>{in1} </body>{especi} &nbsp; {Análisis del tiempo de ejecución} El
análisis del algoritmo de Prim se puede realizar fácilmente por partes. La ini\-cia\-li\-za\-ción del algoritmo
lleva un tiempo de $O(n)$. A continuación, tenemos un bucle </font></a>{<br>{para} <font_arial>{i}}, que se repite
$n-1$ veces. Dentro de este bucle, tenemos varias instrucciones constantes y dos bucles </font></a>{<br>{para}
<font_arial>{j}}, no anidados sino consecutivos. Estos bucles requieren claramente un $O(n)$. Por lo tanto, el
orden total del algoritmo de Prim es $O(n^2)$. La implementación propuesta trabaja con matrices de adyacencia.
Sería posible hacer algunas modificaciones en el procedimiento para usar listas de adyacencia. Si lo hacemos así,
podríamos ahorrarnos algunas instrucciones en el bucle de ``recalcular los costes de $U$''. En su lugar tendríamos
un </font></a>{<br>{para cada} nodo <font_arial>{j} adyacente a <font_arial>{k}...}. El problema es que la
búsqueda del mínimo </font></a>{<font_arial>{MenorCoste}} sigue necesitando $n-2$ pasos, con lo que el tiempo
seguiría siendo un $O(n^2)$. <html>{Algoritmo de Kruskal} La idea subyacente al algoritmo de Kruskal es también
intuitiva. Igual que en el algoritmo de Prim, el árbol de expansión de coste mínimo se construye paso a paso; en
cada paso se añade una arista al árbol. El funcionamiento del algoritmo es el siguiente: <li> </font> Suponiendo
que partimos de un grafo con pesos, $G=(V, A, W)$, comenzamos con un grafo $G'=(V, \emptyset)$. Es decir, el árbol
está compuesto por todos los vértices de $G$ y ningún arco. </font> En cada paso del algoritmo, se elige la arista
de menor coste de $A$ de las que queden por estudiar. Esto es, se van comprobando las aristas de menor a mayor.
</font> Suponiendo que la arista que está siendo estudiada es $(v,w)$, entonces debemos comprobar si se puede
añadir al árbol de expansión, $G'$. En concreto, se podrá añadir siempre que no forme un ciclo en $G'$. Si forma
un ciclo, se descarta. En otro caso, se añade $(v,w)$ a $G'$. </font> Repetir el paso anterior hasta que $G'$ sea
conexo, es decir, hasta que hayamos añadido $n-1$ aristas. </li> En la figura <label>{fig:aecm3} se muestra un
ejemplo de ejecución del algoritmo de Kruskal, para el mismo grafo de la figura <label>{fig:aecm1}.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/aecm3.eps} </body>{center} <form>{Aplicación del algoritmo de
Kruskal. a) Grafo de entrada del algoritmo. b)-e) Pasos de aplicación del algoritmo. f) Árbol de expansión de
coste mínimo resultante.} <meta>{fig:aecm3} </body>{figure} Veamos la aplicación del algoritmo en la figura
<label>{fig:aecm3}. Inicialmente, el árbol de expansión no tendría ninguna arista. Las estudiamos de menor a
mayor. La $(1,3)$ con coste 1 se puede añadir sin problemas (figura <label>{fig:aecm3}b); igual pasa con la
$(4,6)$ con coste 2 (figura <label>{fig:aecm3}c), la $(2,5)$ con coste 3 (figura <label>{fig:aecm3}d), y la
$(3,6)$ con coste 4 (figura <label>{fig:aecm3}e). La siguiente arista con menor coste sería la $(1,4)$ con coste
4. Pero si añadimos esta arista al grafo de la figura <label>{fig:aecm3}e) se formaría un ciclo. Por lo tanto,
esta arista no debe ser añadida, se descarta. Pasamos a la siguiente, la $(3,4)$ con coste 5. También formaría un
ciclo, así que se descarta. A continuación tenemos la $(2,3)$, también con coste 5, que se puede añadir sin formar
un ciclo (figura <label>{fig:aecm3}f). Al añadirla ya tenemos $n-1$ aristas, luego tenemos la solución. En
definitiva, la estructura del algoritmo de Kruskal sería como la siguiente. Utilizamos aquí un pseudocódigo de muy
alto nivel, dando por supuesto que el alumno es capaz de programarlo por sí mismo. <body>{especi} <br>{operación}
Kruskal (<font_arial>{G}: GrafoNDE[real]; <br>{var} <font_arial>{A}: GrafoNDE[real]) <br>{var} <font_arial>{C}:
Lista[arista] <body>{in1} <font_arial>{C}:= ordenar de menor a mayor las aristas de <font_arial>{G}
<font_arial>{A}:= CrearGrafo <font_arial>{A}:= InsertaNodos(1, 2, .., <font_arial>{n}) <br>{mientras}
<font_arial>{A} contenga menos de <font_arial>{n}-1 aristas <br>{hacer} <body>{in1} elegir la siguiente arista
(<font_arial>{v,w}) de <font_arial>{C} <br>{si} la arista (<font_arial>{v,w}) no forma un ciclo en el grafo
<font_arial>{A} <br>{entonces} <body>{in1} InsertaArista(<font_arial>{A}, (<font_arial>{v,w})) </body>{in1}
<br>{finsi} </body>{in1} <br>{finmientras} </body>{in1} </body>{especi} &nbsp; {Comprobación de componentes
conexos} La cuestión que nos queda por resolver en el algoritmo es ¿cómo comprobar rápidamente si la adición de
una arista $(v,w)$ provocará un ciclo o no? Podríamos añadir la arista y aplicar la prueba de aciclicidad vista en
el apartado <label>{sec:grafosbpp}. Pero esa solución sería demasiado lenta. ¿Es posible hacer la comprobación en
un tiempo constante? Si nos fijamos en la figura <label>{fig:aecm3}e), una arista $(v,w)$ dará lugar a un ciclo en
el grafo $G'$, si antes de añadirla ya existía un camino de $v$ a $w$, es decir si $v$ y $w$ están conectados.
Esto ocurría al intentar añadir $(1,4)$. Suponiendo que calculamos los componentes conexos de $G'$ --esto es, los
subconjuntos de nodos conectados-- entonces podemos decir que no se formará un ciclo --y por tanto podemos añadir
la arista-- si $v$ y $w$ están en componentes conexos distintos. Inicialmente, cuando empezamos con $G'=(V,
\emptyset)$, cada nodo será un componente conexo por sí mismo. Cada vez que añadimos una arista juntando dos
componentes conexos. Y, finalmente, el algoritmo acabará cuando sólo tengamos un componente conexo. ¿Cómo
implementamos la comprobación ``dos nodos están en el mismo componente conexo''? Si nos fijamos, la relación
``estar en el mismo componente conexo'' es una relación binaria de equivalencia: es </label>{reflexiva} (un nodo
está en el mismo componente que sí mismo), </label>{simétrica} (si $v$ está en el mismo componente que $w$,
entonces $w$ está en el mismo que $v$) y </label>{transitiva} (también se cumple trivialmente). Por lo tanto, para
implementar la comprobación podemos usar la estructura de relaciones de equivalencia del capítulo 4, estudiada en
el apartado 4.2. Suponiendo que la relación es almacenada en una variable </font></a>{<font_arial>{R}} de tipo
</font></a>{RelacionEquiv[\{1..n\}]}, la comprobación: </font></a>{<br>{si} la arista (<font_arial>{v,w}) no forma
un ciclo en el grafo <font_arial>{A} <br>{entonces}} Se transformaría sencillamente en: </font></a>{<br>{si}
Encuentra(<font_arial>{R}, <font_arial>{v}) $\neq$ Encuentra(<font_arial>{R}, <font_arial>{w}) <br>{entonces}} Y
al añadir una arista </font></a>{(<font_arial>{v}, <font_arial>{w})} a </font></a>{<font_arial>{A}}, deberíamos
unir dos clases de equivalencia distintas, ejecutando: </font></a>{Union(<font_arial>{R}, <font_arial>{v},
<font_arial>{w})} Recordemos que este tipo de datos utilizaba una estructura de representación mediante punteros
al nodo padre. En su versión más eficiente, utilizando equilibrado y compresión de caminos, el tiempo de ejecución
de las operaciones era </label>{casi} un $O(1)$. &nbsp; {Análisis del tiempo de ejecución} Hemos dejado muchas
cosas sin especificar en el algoritmo de Kruskal, así que el análisis del tiempo de ejecución es un tanto
orientativo. En primer lugar, el algoritmo requiere una ordenación previa de las aristas del grafo. En el mejor
caso, por ejemplo utilizando QuickSort, podemos ordenar las $a$ aristas en un tiempo $O(a \log a)$. A
continuación, el algoritmo entra en un bucle </font></a>{<br>{mientras}} que se repite como mínimo $n-1$ veces, si
no se descarta ninguna arista, y como máximo $a$, si no se acaba hasta la última arista</a>{¡Cuidado! El
algoritmo, tal y como está estructurado, requiere que el grafo $G$ sea conexo. En otro caso, acabaría con todas
las aristas pero no saldría del bucle.}. Además, todas las operaciones que hay dentro del bucle requieren un
tiempo constante. Por lo tanto, el tiempo de ejecución del </font></a>{<br>{mientras}} estaría entre $\Omega(n)$ y
$O(a)$. Si añadimos el tiempo de la ordenación de las aristas, tenemos que en todos los casos, mejor o peor, el
tiempo de ejecución sería un $O(a \log a)$. El análisis anterior supone que usamos listas de adyacencia. Si
utilizamos matrices de adyacencia, el paso de extraer todas las aristas necesitaría un $O(n^2)$ adicional;
tendríamos un $O(a \log a + n^2)$. La diferencia podría ser sustancial si el grafo está poco conectado. Por otro
lado, podemos comparar el tiempo con el del algoritmo de Prim, que resuelve el mismo problema. El algoritmo de
Prim tarda un $O(n^2)$, por lo que siempre sería más adecuado si trabajamos con matrices de adyacencia. Con listas
de adyacencia, la relación entre ambos depende de la proporción entre $a \log a$ y $n^2$. Cuantas menos aristas
haya, más adecuado será el algoritmo de Kruskal. <title>Problemas de caminos mínimos} <meta>{sec:caminosminimos}
Una variedad muy importante de problemas sobre grafos son los problemas de caminos mínimos. En un grafo con pesos,
el coste de un camino es la suma de los costes de las aristas por las que pasa. En grafos no etiquetados se puede
asociar el coste de un camino con su longitud, es decir, el número de aristas por las que pasa. Encontrar los
caminos más cortos en un grafo puede tener distintas aplicaciones. Por ejemplo, en un mapa de carreteras, como el
de la figura <label>{fig:grafejemplos1}a), el camino más corto indica la forma de gastar menos gasolina; en una
red de ordenadores el camino más corto dice por dónde debe circular la información para que la comunicación sea
rápida; en un diagrama de flujos de un algoritmo, como el de la figura <label>{fig:grafoflujo}, el camino más
corto del inicio al fin significa la ejecución más rápida del programa. Según lo que pretendamos calcular, podemos
distinguir los siguientes problemas de caminos mínimos: <li> </font> [a)] Camino mínimo entre un par de nodos
dados, $v$ y $w$. </font> [b)] Caminos mínimos entre un nodo origen dado, $v$, y todos los demás. En grafos
dirigidos tendríamos dos problemas equivalentes: desde $v$ a todos los demás nodos, y desde todos los demás nodos
hasta $v$. </font> [c)] Caminos mínimos entre todos los pares de nodos del grafo. </li> Curiosamente, si
intentamos resolver el caso a) nos encontramos con un problema de la misma complejidad que el caso b). Es decir,
la solución para a) consistiría básicamente en calcular los caminos mínimos entre $v$ y todos los demás nodos, y
después quedarse con el que va de $v$ a $w$. Así que vamos a empezar viendo el problema conocido como caminos
mínimos desde un origen. Para resolverlo se utiliza el algoritmo de Edsger W. Dijkstra, un algoritmo clásico en
teoría de grafos. Para solucionar el caso c) simplemente podríamos repetir el algoritmo de Dijkstra por cada
origen. En su lugar vamos a ver otro algoritmo, también dentro de los clásicos, debido a Robert W. Floyd. En la
figura <label>{fig:dijkstra1} se muestra un ejemplo de grafo dirigido con pesos y la resolución del problema de
los caminos más cortos desde el nodo 1 hasta todos los demás. <html>{Caminos mínimos empezando por un origen}
Supongamos, para simplificar, que el nodo origen es $v=1$ y que los costes de las aristas están almacenados en una
matriz de costes $C$, de tamaño $n \times n$. La matriz $C$ es como la utilizada en el algoritmo de Prim. En la
figura <label>{fig:dijkstra1} se muestra un grafo de ejemplo y los caminos más cortos desde el nodo 1 hasta todos
los demás. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/dijkstra1.eps} </body>{center} <form>{Problema de
los caminos mínimos empezando por un origen. a) Grafo de entrada del algoritmo. b) Caminos mínimos resultantes.}
<meta>{fig:dijkstra1} </body>{figure} mínimo valor de $D$ para los nodos que estén en $T$. Para representar $T$
podemos usar una representación sencilla de conjuntos, por ejemplo con un array de booleanos; $T[w]$ será
verdadero o falso si $w$ es candidato o no, respectivamente. Y, finalmente, el punto 3 implica recalcular, para
cada nodo $w$ de $T$ el valor $D[w]$, pudiendo pasar el camino por $v$. Es decir, el camino especial para $w$ será
el mínimo entre el que tenía antes ($D[w]$) y el camino mínimo para $v$ ($D[v]$) más el coste de la arista $(v,w)$
($C[v,w]$). Para resolver el problema de los caminos más cortos desde un nodo $v$ hasta todos los demás contamos
con el <br>{algoritmo de Dijkstra}. El algoritmo garantiza la solución óptima, siempre que los costes de las
aristas sean positivos. Vamos a empezar viendo la lógica del algoritmo y después pasaremos a su implementación.
&nbsp; {Nodos candidatos, seleccionados y caminos especiales} En el funcionamiento del algoritmo de Dijkstra se
considera que el conjunto de vértices $V$ del grafo está descompuesto en dos subconjuntos: <li> </font>
<br>{Conjunto de nodos escogidos, $S$.} Son los nodos para los cuales ya se conoce el camino mínimo desde el
origen, en cierto momento del algoritmo. </font> <br>{Conjunto de nodos candidatos, $T$.} Está compuesto por todos
los demás nodos, para los cuales no se conoce todavía el camino más corto. </li> En esencia, el algoritmo de
Dijkstra consiste en ir sacando nodos del conjunto de candidatos y añadirlos al conjunto de escogidos. Para los
nodos de $T$ no sabemos todavía los caminos mínimos, pero lo que sí conocemos es el camino más corto desde el
origen pasando por nodos escogidos, es decir los de $S$. Esto es lo que se conoce como caminos especiales. Un
<br>{camino especial} es un camino mínimo desde el origen hasta un nodo cualquiera, pasando sólo por nodos que
están en $S$. El funcionamiento del algoritmo de Dijkstra es el siguiente: <body>{enumerate} </font> Inicialmente,
el conjunto de nodos escogidos $S=\{1\}$, y todos los demás nodos son candidatos. Es fácil calcular los caminos
especiales; serán los caminos directos (de longitud 1) puesto que no se puede pasar por otros nodos intermedios.
Por lo tanto, el coste del camino especial mínimo a cada $w$ será simplemente $C[1,w]$. </font> Elegir un nodo del
conjunto de candidatos $T$, para añadirlo a $S$. ¿Qué nodo se elige? Pues aquel cuyo camino especial sea el menor.
Para ese nodo, se puede garantizar que el ``camino especial mínimo'' es, de hecho, el ``camino mínimo desde el
origen''. </font> Si el nodo seleccionado en el paso anterior es $v$, entonces al añadirlo a $S$ tenemos que
recalcular todos los caminos especiales de los demás nodos de $T$. </font> El algoritmo acabará cuando todos los
nodos hayan sido seleccionados. Cuando se cumpla esto, $S=V$, los caminos especiales pueden pasar por todos los
nodos. En consecuencia, los caminos especiales serán los caminos mínimos desde el origen. </body>{enumerate} Para
almacenar los costes de los caminos especiales, el algoritmo de Dijkstra utiliza un array
</font></a>{<font_arial>{D}: <br>{array} [2..<font_arial>{n}] <br>{de} real}. El punto 1 nos dice que cada
posición $w$ se debe inicializar con: $D[w]:= C[1,w]$. El punto 2 se traduce en buscar el <body>{center}
</tr></html>{cap5/actdijkstra.eps} </body>{center} Así que el paso de actualización al añadir
</font></a>{<font_arial>{v}} diría: <body>{especi} <body>{in1} <br>{para cada} nodo <font_arial>{w} adyacente a
<font_arial>{v} y siendo <font_arial>{Miembro}(<font_arial>{T}, <font_arial>{w}) <br>{hacer} <body>{in1}
<font_arial>{D}[<font_arial>{w}]:= min(<font_arial>{D}[<font_arial>{w}],
<font_arial>{D}[<font_arial>{v}]+<font_arial>{C}[<font_arial>{v},<font_arial>{w}]) </body>{in1} <br>{finpara}
</body>{in1} </body>{especi} Sólo nos queda un pequeño detalle. Tenemos calculados en </font></a>{<font_arial>{D}}
los costes de los caminos mínimos. Pero nos falta conocer cuáles son esos caminos, es decir por qué nodos pasa
cada camino mínimo. Para representar los caminos usamos otro array </font></a>{<font_arial>{P}:
<font_arial>{array} [2..<font_arial>{n}] <br>{de} Nodo}, tal que $P[v]$ contiene el vértice inmediatamente
anterior a $v$ en el camino más corto. Es decir, el camino más corto para un $v$ cualquiera sería: <body>{center}
1 $<symbol>$ ... $P[P[P[v]]]$\ $<symbol>$\ $P[P[v]]$\ $<symbol>$\ $P[v]$\ $<symbol>$\ $v$ </body>{center}
Inicialmente $P[v]=1$ para todo $v \neq 1$, es decir, los caminos mínimos son los caminos directos. Por otro lado,
en el paso de actualización, si el camino más corto para $w$ pasa por $v$, entonces debemos indicarlo en $P[w]$.
<body>{especi} <body>{in1} <br>{para cada} nodo <font_arial>{w} adyacente a <font_arial>{v} <br>{hacer}
<body>{in1} <br>{si} Miembro(<font_arial>{T}, <font_arial>{w}) Y
(<font_arial>{D}[<font_arial>{v}]+<font_arial>{C}[<font_arial>{v},<font_arial>{w}]) $<$
<font_arial>{D}[<font_arial>{w}] <br>{entonces} <body>{in1} <font_arial>{D}[<font_arial>{w}]:=
<font_arial>{D}[<font_arial>{v}]+<font_arial>{C}[<font_arial>{v},<font_arial>{w}]
<font_arial>{P}[<font_arial>{w}]:= <font_arial>{v} </body>{in1} <br>{finsi} </body>{in1} <br>{finpara}
</body>{in1} </body>{especi} &nbsp; {Algoritmo de Dijkstra} Recopilando todo lo que hemos estudiado hasta ahora
del algoritmo de Dijkstra, vamos a ver una posible implementación en pseudocódigo. Damos por supuesto el tipo
</font></a>{Conjunto[Rango]}, implementado mediante arrays de booleanos. <body>{especi} <body>{in1}
<br>{operación} Dijkstra (<font_arial>{C}: <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}] <br>{de} real;
<br>{var} <font_arial>{D}: <br>{array} [2..<font_arial>{n}] <br>{de} real; <br>{var} <font_arial>{P}: <br>{array}
[2..<font_arial>{n}] <br>{de} entero) <br>{var} <font_arial>{T}: Conjunto[2..<font_arial>{n}] <body>{in1}
<br>{para} <font_arial>{i}:= 2, ...,<font_arial>{n} <br>{hacer} <body>{in1} <font_arial>{D}[<font_arial>{i}]:=
<font_arial>{C}[1, <font_arial>{i}] <font_arial>{P}[<font_arial>{i}]:= 1 Inserta(<font_arial>{T}, <font_arial>{i})
</body>{in1} <br>{finpara} <br>{para} <font_arial>{i}:= 2, ...,<font_arial>{n} <br>{hacer} <body>{in1}
<font_arial>{v}:= vértice con Miembro(<font_arial>{T}, <font_arial>{v})=verdadero y
<font_arial>{D}[<font_arial>{v}] mínimo Suprime(<font_arial>{T}, <font_arial>{v}) <br>{para cada} nodo
<font_arial>{w} adyacente a <font_arial>{v} <br>{hacer} <body>{in1} <br>{si} Miembro(<font_arial>{T},
<font_arial>{w}) Y (<font_arial>{D}[<font_arial>{v}]+ <font_arial>{C}[<font_arial>{v},<font_arial>{w}]) $<$
<font_arial>{D}[<font_arial>{w}] <br>{entonces} <body>{in1} <font_arial>{D}[<font_arial>{w}]:=
<font_arial>{D}[<font_arial>{v}]+<font_arial>{C}[<font_arial>{v},<font_arial>{w}]
<font_arial>{P}[<font_arial>{w}]:= <font_arial>{v} </body>{in1} <br>{finsi} </body>{in1} <br>{finpara}
</body>{in1} <br>{finpara} </body>{in1} </body>{in1} </body>{especi} Para simplificar la estructura, no se
desarrolla la operación ``</font></a>{v:= vértice con Miembro(<font_arial>{T}, <font_arial>{v})=verdadero y
<font_arial>{D}[<font_arial>{v}] mínimo}'', que consistiría en un simple recorrido secuencial de un array. En la
tabla <label>{tab:dijkstra2} se muestra un ejemplo de ejecución del algoritmo de Dijkstra, para el grafo de la
figura <label>{fig:dijkstra1}. <body>{table}[!ht] <body>{center} </tr></html>{cap5/dijkstra2.eps} </body>{center}
<form>{Aplicación del algoritmo de Dijkstra sobre el grafo de la figura <label>{fig:dijkstra1}. Aparecen en
negrita los valores que se modifican en cada paso.} <meta>{tab:dijkstra2} </body>{table} &nbsp; {Demostración de
la optimalidad del algoritmo} Es posible demostrar formalmente que el algoritmo de Dijkstra es óptimo --es decir
encuentra siempre los caminos mínimos-- suponiendo que las aristas tienen peso positivo. Para ver la demostración,
vamos a diferenciar primero entre los distintos conceptos que entran en juego: <body>{enumerate} </font> Camino
mínimo en el grafo: es lo que buscamos, lo que podríamos llamar el mínimo ``absoluto''. Denotamos el coste del
camino mínimo por $CosteMin(v  <blockquote> w)$. </font> Camino especial: es un camino mínimo pero restringido a
pasar sólo por nodos escogidos, de $S$. Lo denotamos por $CosteEsp(1  <blockquote> w)$, siendo 1 el nodo origen.
</font> Array </font></a>{<font_arial>{D}}: es el coste del camino que calcula el algoritmo de Dijkstra, para cada
nodo distinto de 1. </body>{enumerate} Por un lado, está claro que cuando $S=V$ entonces $CosteEsp \equiv
CosteMin$. Así que si demostramos que </font></a>{<font_arial>{D}} $\equiv CosteEsp$, tendremos demostrado que el
algoritmo de Dijkstra es óptimo. La demostración tiene dos partes: 1) $CosteEsp \equiv CosteMin$ para los nodos
que están en $S$; 2) </font></a>{<font_arial>{D}} $\equiv CosteEsp$ para todos los nodos antes de añadirlos a $S$.
<p><br>{1) El menor camino especial hasta un nodo de $T$ es un camino mínimo.} Esto implica, de forma directa, que
para los nodos añadidos a $S$ los caminos especiales son caminos mínimos. La demostración de este punto garantiza
que el orden de selección de los nodos de $T$ debe ser, como ocurre en el algoritmo, por el menor valor de $D$.
Sea $v$ el nodo de $T$ con menor camino especial. Pero supongamos, por reducción al absurdo, que ese camino
especial no es un camino mínimo, es decir $CosteEsp(1  <blockquote> v) > CosteMin(1  <blockquote> v)$. Al no ser
especial, su camino mínimo debe pasar por algún nodo que no esté en $S$, como se muestra en la figura
<label>{fig:demdijkstra}a). Sea $k$ el primero de estos nodos fuera de $S$. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/demdijkstra.eps} </body>{center} <form>{Demostración del algoritmo de Dijkstra. a) El menor
camino especial es un camino mínimo. b) El camino especial es el que calcula el algoritmo de Dijkstra.}
<meta>{fig:demdijkstra} </body>{figure} El coste de este hipotético camino mínimo sería: $CosteMin(1
 <blockquote> v) = CosteMin(1  <blockquote> k) + CosteMin(k  <blockquote> v)$. Pero como los pesos son
positivos: $CosteMin(k  <blockquote> v) > 0$; luego: $CosteMin(1  <blockquote> v) > CosteMin(1  <blockquote> k)$.
Ahora bien, como hemos tomado en $k$ el primero de los nodos fuera de $S$, entonces su camino mínimo es un camino
especial y tenemos que $CosteEsp(1  <blockquote> v) > CosteEsp(1  <blockquote> k)$. Llegamos a una contradicción:
el menor camino especial no es el de $v$ (como habíamos supuesto al principio) sino el de $k$. Por lo tanto, el
menor camino especial debe ser el camino mínimo de ese nodo. <p><br>{2) <bold>n</bold>{D}[<bold>n</bold>{w}]
almacena efectivamente el coste del camino especial a <bold>n</bold>{w}.} La demostración de este punto garantiza
que el proceso de actualización del algoritmo de Dijkstra, al añadir un nodo $v$ a $S$, es correcto. La
demostración se puede hacer por inducción. Inicialmente, cuando $S=\{1\}$ está claro que $D[w]$ contiene los
caminos especiales. Supongamos, por hipótesis de inducción, que en cierto momento $D$ almacena los caminos
especiales. Veamos que después de añadir un nuevo nodo $v$ a $S$, el array $D$ sigue guardando los caminos
especiales. Sea $w$ un nodo de $T$ cualquiera. El algoritmo de Dijkstra toma el mínimo entre $D[w]$ y
$D[v]+C[v,w]$. Supongamos, por reducción al absurdo, que el camino especial para $w$ pasa por $v$ pero no es el
camino: $1  <blockquote> v <symbol> w$, sino que después de $v$ pasa por otros nodos de $S$, siendo del tipo: $1
 <blockquote> v  <blockquote> k <symbol> w$. En la figura <label>{fig:demdijkstra}b) se ilustra esta
hipotética situación. El coste de este camino sería: $CosteEsp(1  <blockquote> v) + CosteMin(v  <blockquote> k) +
C[k,w]$. Ahora bien, como $k$ estaba en $S$ antes que $v$, entonces el camino especial para $k$ ya era un camino
mínimo, así que el coste de $1  <blockquote> v  <blockquote> k$ es mayor que $CosteEsp(1  <blockquote> k)$. Usando
la hipótesis de inducción, $D[k] = CosteEsp(1  <blockquote> k) < CosteEsp(1  <blockquote> v) = D[v]$, luego
$D[k]+C[k,w] < D[v]+C[v,w]$. Por lo tanto, tenemos una contradicción: el camino especial para $w$ pasaría solo por
$k$ y no por $v$. En definitiva, la actualización del algoritmo de Dijkstra garantiza que $D$ almacena los caminos
especiales. &nbsp; {Análisis del tiempo de ejecución} Igual que con la búsqueda el profundidad, vamos a realizar
el estudio del trabajo total realizado por el algoritmo. En primer lugar tenemos una inicialización de los arrays
</font></a>{<font_arial>{D}} y </font></a>{<font_arial>{P}}, que requiere un $O(n)$, para un grafo de $n$ nodos. A
continuación tenemos un </font></a>{<br>{para} <font_arial>{i}}, dentro un </font></a>{<br>{para cada} adyacente}
y dentro una comparación y algunas operaciones constantes. Razonando como en la búsqueda en profundidad, vemos que
el resultado final es que se recorrerán todas las aristas del grafo, comprobando todas las adyacencias. Por lo
tanto, con matrices de adyacencia tenemos $O(n^2)$ y con listas $O(n+a)$. Pero no podemos olvidar la operación
``</font></a>{v:= vértice con Miembro(<font_arial>{T}, <font_arial>{v})=verdadero ...}'', que implica un recorrido
secuencial del array </font></a>{<font_arial>{D}} para cada uno de los $n$ nodos. Por lo tanto, tendríamos que
sumar un $O(n^2)$. Con matrices de adyacencia tenemos en total un $O(n^2)$. Con listas de adyacencia: $O(n+a+
n^2)=O(n^2)$, ya que siempre $a \leq n^2$. Se podría mejorar el tiempo con listas de adyacencia, si la operación
anterior no necesitara un recorrido secuencial del array para localizar el mínimo. Por ejemplo, si los nodos se
almacenan en una estructura de <br>{montículos de mínimos} se podría encontrar en un $O(1)$ y luego suprimirlo en
$O(\log n)$. También podríamos usar un árbol AVL, con un $O(\log n)$ para ambas operaciones. No obstante, esta
estructura ordenada podría modificarse cada vez que se actualice </font></a>{<font_arial>{D}}, dentro del
</font></a>{<br>{si}}. La actualización requiere un $O(\log n)$ en ambos casos, y se puede repetir como máximo
$a+n$ veces. Por lo tanto, el orden de complejidad del algoritmo con esta implementación sería $O(n+a+(a+n)\log
n)= O((a+n)\log n)$. El tiempo será menor que $O(n^2)$ cuando $a \ll n^2$, es decir, cuando el grafo sea disperso.
<html>{Caminos más cortos entre todos los vértices} En cierto sentido, el problema de los caminos mínimos entre
todos los pares de vértices abarca --como situación más general-- al problema de los caminos mínimos desde un
origen. Como ya propusimos al principio de la sección, para resolverlo se podría aplicar el algoritmo de Dijkstra
repetidas veces, eligiendo cada vez como origen un vértice diferente. El orden de complejidad de esta solución
sería $O(n^3)$ si usamos matrices de adyacencia y $O(n(a+n) \log n)$ con listas de adyacencia, siendo $n$ el
número de nodos y $a$ el número de aristas. Pero existe una solución más directa y elegante, que es conocida como
el <br>{algoritmo de Floyd}. Igual que en el algoritmo de Dijkstra, trabajamos con una matriz de costes $C$ de
tamaño $n \times n$, que tendrá un $+ </blockquote>fty$ en las posiciones donde no exista una arista. También como
en el algoritmo de Dijkstra, los costes deben ser siempre positivos. El resultado final del algoritmo vendrá dado
en otra matriz $D$, de tamaño $n \times n$, en la que cada posición $D[v,w]$ indica el coste del camino mínimo
entre $v$ y $w$. Si, al final del algoritmo, tenemos que $D[v,w]=+ </blockquote>fty$ entonces quiere decir que no
existe ningún camino entre $v$ y $w$. Obviamente, en un grafo no dirigido siempre será $D[v,w]=D[w,v]$. &nbsp;
{Pivotaje sobre un nodo y programación dinámica} El algoritmo de Floyd da lugar a la idea de la programación
dinámica, que es una técnica general de diseño de algoritmos. En esencia, la idea del algoritmo de Floyd es la
siguiente. Inicialmente, en la matriz $D$ tenemos los costes de las aristas entre todos los nodos, es decir $D=
C$. El algoritmo está compuesto por $n$ pasos, iterando con una variable $k$, desde 1 hasta $n$. En cada paso $k$,
la matriz $D$ contendrá los costes de los caminos mínimos entre todos los pares de nodos, pudiendo pasar por los
$k$ primeros nodos, como nodos intermedios de los caminos. Es decir, cuando $k=1$ tenemos que calcular los caminos
mínimos entre todos los $v$ y $w$ pasando, o no, por el nodo 1. Cuando $k=2$ calculamos todos los caminos mínimos
pudiendo pasar por los nodos 1 y 2. Y así sucesivamente hasta tener $k=n$. Al final tendremos en $D$ los caminos
más cortos pudiendo pasar por todos los vértices, es decir lo que buscamos, los caminos mínimos
</label>{absolutos}. En cada paso $k$ del algoritmo, decimos que el vértice $k$ actúa como <br>{pivote}. El
proceso de pivotaje consiste en comprobar, para todos los pares de vértices $i$ y $j$, si su camino mínimo debe
pasar por $k$ o no. Es decir, en el caso $k$ se debe eligir para todos los pares $i$, $j$ una posibilidad de
entre: <li> </font> No pasar por el vértice $k$. En ese caso, el coste del camino no varía. Seguiría siendo</a>{El
término $D_{k-1}$ significa: ``la matriz matriz $D$ en el paso $k-1$''. Y, según lo que hemos visto, $D_x$
almacena los caminos mínimos entre todos los pares pudiendo pasar por los $x$ primeros nodos.}: $D_{k-1}[i,j]$.
</font> Pasar por el vértice $k$. En este caso, el coste sería ir de $i$ a $k$ y luego ir de $k$ a $j$. Por lo
tanto, el coste ahora sería: $D_{k-1}[i,k]+D_{k-1}[k,j]$. </li> <body>{center} </tr></html>{cap5/actfloyd.eps}
</body>{center} ¿Con cuál de las dos opciones nos quedamos? Pues, obviamente, con la que tenga menor coste:
$D_k[i,j]:= min(D_{k-1}[i,j], D_{k-1}[i,k]+D_{k-1}[k,j])$. Así que la matriz $D$ en el paso $k$ se calcula usando
la misma $D$ en el paso $k-1$. Es más, se puede demostrar que en el paso $k$ ni la fila ni la columna $k$ de la
matriz se modifican</a>{Por ejemplo, la fila $k$ sería $D_k[k,j]:= min(D_{k-1}[k,j], D_{k-1}[k,k]+D_{k-1}[k,j]$.
Como hemos supuesto que todos los pesos son positivos, entonces $D_{k-1}[k,j] \leq D_{k-1}[k,k]+D_{k-1}[k,j]$. De
esta forma, $D_k[k,j]:= D_{k-1}[k,j]$, la fila $k$ no cambia en el paso $k$.}. Por lo tanto, podemos usar la misma
matriz $D$ para todos los pasos del algoritmo, sin necesidad de distinguir $D_{k-1}$ de $D_k$. De esta forma, el
núcleo del algoritmo de Floyd consistiría en lo siguiente: <body>{especi} <body>{in1} <br>{para} <font_arial>{k}:=
1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{para} <font_arial>{i}:= 1, ..., <font_arial>{n} <br>{hacer}
<body>{in1} <br>{para} <font_arial>{j}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1}
<font_arial>{D}[<font_arial>{i}, <font_arial>{j}]:= min(<font_arial>{D}[<font_arial>{i}, <font_arial>{j}] ,
<font_arial>{D}[<font_arial>{i}, <font_arial>{k}]+<font_arial>{D}[<font_arial>{k}, <font_arial>{j}]) </body>{in1}
<br>{finpara} </body>{in1} <br>{finpara} </body>{in1} <br>{finpara} </body>{in1} </body>{especi} Al final del
algoritmo tenemos almacenados en $D$ los costes de los caminos mínimos entre todos los pares de nodos. Pero
¿cuáles son esos caminos? Igual que en el algoritmo de Dijkstra, necesitamos una estructura para almacenar los
nodos por los que pasan los caminos. Esta estructura será una matriz $P$, de tamaño $n \times n$. En cada posición
$P[i,j]$ tendremos un nodo intermedio por el cual pasa el camino mínimo de $i$ a $j$. En otras palabras, el camino
mínimo de $i$ a $j$ sería: <body>{center} $i <symbol> ... <symbol> P[i,j] <symbol> ... <symbol> j$ </body>{center}
Si el camino mínimo es directo, entonces $P[i,j]=0$. Inicialmente, todos los caminos de $D$ serán caminos directos
y $P[i,j]=0$, para todo $i$ y $j$. Por otro lado, si en un paso de pivotaje encontramos que el mínimo es
$D[i,k]+D[k,j]$, entonces deberíamos indicar que el camino mínimo entre $i$ y $j$ pasa por $k$: $P[i,j]:= k$.
&nbsp; {Algoritmo de Floyd} Juntando todo lo anterior, una posible implementación del algoritmo de Floyd sería la
siguiente. <body>{especi} <br>{operación} Floyd (<font_arial>{C}: <br>{array} [1..<font_arial>{n},
1..<font_arial>{n}] <br>{de} real; <br>{var} <font_arial>{D}: <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}]
<br>{de} real; <br>{var} <font_arial>{P}: <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}] <br>{de} entero)
<body>{in1} <br>{para} <font_arial>{i}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{para}
<font_arial>{j}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <font_arial>{D}[<font_arial>{i},
<font_arial>{j}]:= <font_arial>{C}[<font_arial>{i}, <font_arial>{j}] <font_arial>{P}[<font_arial>{i},
<font_arial>{j}]:= 0 </body>{in1} <br>{finpara} <font_arial>{D}[<font_arial>{i}, <font_arial>{i}]:= 0 </body>{in1}
<br>{finpara} <br>{para} <font_arial>{k}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{para}
<font_arial>{i}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{para} <font_arial>{j}:= 1, ...,
<font_arial>{n} <br>{hacer} <body>{in1} <br>{si} <font_arial>{D}[<font_arial>{i}, <font_arial>{j}] $<$
<font_arial>{D}[<font_arial>{i}, <font_arial>{k}]+<font_arial>{D}[<font_arial>{k}, <font_arial>{j}] <br>{entonces}
<body>{in1} <font_arial>{D}[<font_arial>{i}, <font_arial>{j}]:= <font_arial>{D}[<font_arial>{i},
<font_arial>{k}]+<font_arial>{D}[<font_arial>{k}, <font_arial>{j}] <font_arial>{P}[<font_arial>{i},
<font_arial>{j}]:= <font_arial>{k} </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1} <br>{finpara}
</body>{in1} <br>{finpara} </body>{in1} </body>{especi} La asignación: $D[i,i]:= 0$, es requerida en muchas
aplicaciones, en las cuales la distancia de un vértice a sí mismo siempre debe ser tomada como cero; y esto aun
cuando existan aristas del tipo $(i,i)$, como en el grafo de la figura <label>{fig:floyd1}. Sin embargo, la
asignación no es imprescindible para que el algoritmo funcione correctamente. Muestra el resultado de insertar los
siguientes elementos en un árbol trie: patria, patriada, patriar, patriarca, patriarcadgo, patriarcado. Elige un
tipo de representación para los nodos del árbol y haz una estimación aproximada de la memoria ocupada para este
ejemplo concreto. ¿Qué pasaría si no la hacemos? En ese caso, el algoritmo calcularía el coste del camino mínimo
de $i$ a $i$ pasando por algún otro nodo. Si el grafo es dirigido, sería el ciclo de menor coste que pasa por $i$.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/floyd1.eps} </body>{center} <form>{Ejemplo de grafo dirigido,
donde se permiten aristas del tipo $<$<bold>n</bold>{v,v}$>$.} <meta>{fig:floyd1} </body>{figure} En la figura
<label>{fig:floyd2} se muestra la aplicación del algoritmo de Floyd sobre el grafo de la figura
<label>{fig:floyd1}. Se muestra graficamente la idea del pivotaje. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/floyd2.eps} </body>{center} <form>{Aplicación del algoritmo de Floyd sobre el grafo de la figura
<label>{fig:floyd1}. En el paso $k$ ni la fila ni la columna $k$ se modifican.} <meta>{fig:floyd2} </body>{figure}
Por otro lado, ¿cómo podemos recuperar los nodos por los que pasa el camino mínimo entre cada $i$ y $j$? Sabemos
que el camino mínimo pasa por $P[i,j]$. Razonando de manera inductiva, tendríamos que encontrar los trozos de
camino de $i$ a $P[i,j]$, y luego de $P[i,j]$ a $j$. Y así mientras $P[i,j]$ sea distinto de 0. El algoritmo
podría ser el siguiente. <body>{especi} <br>{operación} Camino (<font_arial>{P}: <br>{array} [1..<font_arial>{n},
1..<font_arial>{n}] <br>{de} entero; <font_arial>{i}, <font_arial>{j}: entero) <body>{in1} <font_arial>{k}:=
<font_arial>{P}[<font_arial>{i}, <font_arial>{j}] <br>{si} <font_arial>{k} $\neq$ 0 <br>{entonces} <body>{in1}
Camino(<font_arial>{P}, <font_arial>{i}, <font_arial>{k}) <br>{escribir}(<font_arial>{k}) Camino(<font_arial>{P},
<font_arial>{k}, <font_arial>{j}) </body>{in1} <br>{finsi} </body>{in1} </body>{especi} En el anterior algoritmo,
faltaría por escribir los propios vértices $i$ y $j$. <body>{especi} <body>{in1} <br>{escribir}(<font_arial>{i})
Camino(<font_arial>{i}, <font_arial>{j}) <br>{escribir}(<font_arial>{j}) </body>{in1} </body>{especi} &nbsp;
{Análisis del tiempo de ejecución} El análisis del tiempo de ejecución del algoritmo de Floyd resulta bastante
sencillo. Trivialmente, la inicialización requiere $2n^2 + n$ asignaciones, y el proceso de </body>{in1}
<br>{finpara} </body>{in1} pivotaje $n^3$ comparaciones, que en caso de ser ciertas añadirían $2n^3$ asignaciones.
En total, el orden de complejidad del algoritmo es un $O(n^3)$. Comparado con el algoritmo de Dijkstra repetido
$n$ veces, tenemos los mismos tiempos si usando matrices de adyacencia. Las $n$ ejecuciones del algoritmo de
Dijkstra darían un $O(n^3)$. Sin embargo, el algoritmo de Floyd es más directo y sencillo de programar, por lo que
será más adecuado si necesitamos los caminos entre todos los pares. Por otro lado, con listas de adyacencia el
algoritmo de Dijkstra repetido $n$ veces tardaría un $O((a+n)n \log n)$. Si suponemos que el grafo es conexo,
tendríamos $O(a~n \log n)$. Comparado con el $O(n^3)$ del algoritmo de Floyd, tardaría menos tiempo conforme $a$
fuera menor. Es decir, tendríamos una mejora si el grafo está poco conectado. &nbsp; {Cierre transitivo} Un
problema muy relacionado con el de los caminos mínimos es el problema del cierre transitivo. Dado un grafo
cualquiera, queremos calcular si existe un camino entre dos vértices o no, para todos los vértices del grafo. Por
ejemplo, si aplicamos el algoritmo de Floyd sobre un grafo con pesos, entonces si $D[i,j]=+ </blockquote>fty$ al
final del algoritmo, no existe ningún camino entre $i$ y $j$. En otro caso sí existe algún camino. El cierre
transitivo se puede aplicar sobre grafos sin pesos, utilizando la matriz de adyacencia $M$ del grafo. El resultado
será una matriz $A$ de conectividad. Es decir, $M[i,j]$ indica si existe una arista $(i,j)$ y $A[i,j]$ indica si
existe un camino de $i$ a $j$. El problema se puede resolver con el algoritmo de Warshall. El algoritmo es muy
parecido al de Floyd, pero en lugar de razonar con costes lo hacemos con booleanos. En cada paso $k-1$, indicamos
en $A[i,j]$ si existe camino entre $i$ y $j$ pudiendo pasar por los $k-1$ primeros nodos. Entonces, existirá
camino en el paso $k$ si existía en el paso $k-1$ o bien si existe un camino de $i$ a $k$ y otro de $k$ a $j$.
Escrito como una expresión booleana: $A[i,j]:= A[i,j] ~ O ~ (A[i,k] ~ Y ~ A[k,j])$. El algoritmo sería sencillo.
<body>{especi} <br>{operación} Warshall (<font_arial>{M}: <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}]
<br>{de} booleano; <br>{var} <font_arial>{A}: <br>{array} [1..<font_arial>{n}, 1..<font_arial>{n}] <br>{de}
booleano) <body>{in1} <font_arial>{A}:= <font_arial>{M} \ \ \ \ <font_arial>{// Inicialización} <br>{para}
<font_arial>{k}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{para} <font_arial>{i}:= 1, ...,
<font_arial>{n} <br>{hacer} <body>{in1} <br>{para} <font_arial>{j}:= 1, ..Podemos definir el concepto de
<br>{excentricidad de un nodo} como la mayor de las distancias mínimas de los caminos que llegan a ese nodo..,
<font_arial>{n} <br>{hacer} <body>{in1} <font_arial>{A}[<font_arial>{i}, <font_arial>{j}]:=
<font_arial>{A}[<font_arial>{i}, <font_arial>{j}] O (<font_arial>{A}[<font_arial>{i}, <font_arial>{k}] Y
<font_arial>{A}[<font_arial>{k}, <font_arial>{j}]) </body>{in1} <br>{finpara} </body>{in1} <br>{finpara}
</body>{in1} <br>{finpara} </body>{in1} </body>{especi} Claramente, el tiempo de ejecución del algoritmo de
Warshall es un $O(n^3)$. Aunque el algoritmo se puede ver como una sencilla modificación del algoritmo de Floyd,
el mérito pares de nodos.  El <br>{centro de Warshall es que su algoritmo es previo al de Floyd. &nbsp; {El centro
de un grafo} Vamos a ver un ejemplo de aplicación del problema de los caminos mínimos entre todos los de un grafo}
con pesos se define como el vértice con menor valor de excentricidad. Es decir, es el vértice que tiene más
cercano su vértice más distante. Supongamos, por ejemplo, el grafo de carreteras mostrado a la izquierda en la
figura <label>{fig:centro3}. La cuestión es ¿cómo calcular el centro del grafo? <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/centro3.eps} </body>{center} <form>{El centro de un grafo. Izquierda: grafo de carreteras.
Derecha: caminos mínimos entre ciudades y excentricidad de cada ciudad. El centro del grafo es
</font></a>{Madrid}.} <meta>{fig:centro3} </body>{figure} El problema se puede resolver fácilmente utilizando los
algoritmos que hemos visto. En concreto, deberíamos hacer lo siguiente: <li> </font> [1] Calcular la distancia
mínima entre cada par de nodos, utilizando el algoritmo de Floyd (o Dijkstra repetido $n$ veces). Obten(o por
fila, si el grafo es no dirigido). </font> [3] Devolver el nodo $v$ con menor valor de $excentricidad(v)$. </li>
En la derecha de la figura <label>{fig:centro3} se muestra el resultado del algoritmo para el grafo de la
izquierda. El centro del grafo sería el nodo </font></a>{Madrid}. ¿Cuál es el orden de complejidad del algoritmo?
Si utilizamos el algoritmo de Floyd, el punto 1 tarda un $O(n^3)$, el 2 necesita un $O(n^2)$ y el 3 un $O(n)$. En
total, el tiempo sería un $O(n^3)$. <title>Algoritmos sobre grafos dirigidos} En esta sección vamos a estudiar
tres problemas relacionadas con los grafos dirigidos: el cálculo de los componentes fuertemente emos una matriz de
costes mínimos $D$. </font> [2] Calcular las excentricidades: $excentricidad(v)= max\{D[w, v] ~|~ \forall~ w
</blockquote> V\}$. Es decir, tomamos los máximos por columnas conexos, el recorrido en orden topológico sobre
grafos dirigidos acíclicos y los problemas de flujo en redes. <html>{Componentes fuertemente conexos} Como
estudiamos en la si el grafo no tiene ninguna arista, entonces cada nodo será un componente conexo por sí mismo.
La búsqueda de los componentes conexos, o fuertemente conexos, en un grafo puede tener numerosas utilidades. Por
ejemplo, en un grafo como el de la figura <label>{fig:compcon1}, los nodos representan páginas web y las aristas
los enlaces de una páginas con otras. Los componentes fuertemente conexos son todas las páginas que se referencian
entre sí, bien directamente o a través de otras. La idea de los flujos, que van desde $s$ hasta $t$, es muy
próxima a la de un camino por el que circula cierto fluido. Cada unidad de flujo que llega hasta un nodo, debe
salir por alguna de sus aristas. Por lo tanto, un posible algoritmo podría basarse en encontrar caminos $(s,v_1,
v_2, ..., v_k, t)$ en $G$. Por ese camino podemos mandar cierta cantidad de flujo. ¿Cuánto? Pues todo lo que
quepa. Por ejemplo, si en el grafo $G$ de la figura <label>{fig:flujos1} tomamos el camino $(s,a,b,t)$, vemos que
las aristas por las que pasa tienen pesos: 5, 2, 4. El máximo flujo que podemos mandar por ese camino está
limitado por el mínimo de las capacidades por las que pasa el camino; en este caso 2. De esta forma, el algoritmo
iría encontrando caminos en $G$, añadiendo los flujos correspondientes al grafo $F$ y quitándolos de $G$. Y así
seguiría hasta que no queden más caminos para enviar flujo. Los componentes fuertemente conexos del grafo de la
figura <label>{fig:compcon4}a) serían: </font></a>{\{a,b,d\}} y </font></a>{\{c,e\}}. Por otro lado, el orden de
complejidad del algoritmo viene dado por el orden del procedimiento </font></a>{bpp}. Con matrices de adyacencia
tendríamos un $O(n^2)$ y con listas un $O(n+a)$. &nbsp; {Grafo reducido de un grafo dirigido} <body>{figure}[!ht]
<body>{center} </tr></html>{cap5/compcon1.eps} </body>{center} <form>{El problema de los componentes fuertemente
conexos. a) Grafo de páginas web y referencias entre las mismas. b) Componentes fuertemente conexos resultantes.}
<meta>{fig:compcon1} </body>{figure} &nbsp; {Componentes conexos en grafos no dirigidos} En grafos no dirigidos,
suponiendo que el grafo representa vías de comunicación, los distintos componentes conexos indican nodos entre los
cuales es imposible la comunicación. El cálculo de los componentes conexos en grafos no dirigidos es bastante
sencillo, así que lo resolveremos como un ejemplo. <body>{ejemplo} <meta>{eje:compoconexos} Dar un algoritmo para
encontrar los componentes conexos de un grafo no dirigido, como el mostrado en la figura <label>{fig:compcon2}.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/compcon2.eps} </body>{center} <form>{Grafo no dirigido.
Encontrar los componentes conexos.} <meta>{fig:compcon2} </body>{figure} Suponiendo que arrancamos una búsqueda
primero en profundidad, o en anchura, desde un nodo de un componente cualquiera, está claro que se visitarán todos
los nodos de ese componente y sólo esos nodos. Por ejemplo, si arrancamos la búsqueda en $v=1$, se visitarán los
nodos $1, 2, 3, 4$. Por lo tanto, cada árbol de expansión en profundidad corresponderá a un componente conexo. La
implementación se basaría en una búsqueda en profundidad, con algunas modificaciones. En concreto, el array
</font></a>{<font_arial>{marca}} será un array de enteros, incializado a 0, donde almacenaremos el número de
componente al que pertenece cada nodo. Cada vez que visitamos un nodo, ponemos el componente que le corresponde.
Suponemos que el entero </font></a>{<font_arial>{numeroComponentes}} es una variable global. La implementación
sería la siguiente: <body>{especi} <body>{in1} <br>{operación} CalculaComponentesConexos <body>{in1} BorraMarcas
<font_arial>{numeroComponentes}:= 0 <br>{para} <font_arial>{v}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1}
<br>{si} <font_arial>{marca}[<font_arial>{v}] = 0 <br>{entonces} <body>{in1} <font_arial>{numeroComponentes}:=
<font_arial>{numeroComponentes} + 1 <font_arial>{marca}[<font_arial>{v}]:= <font_arial>{numeroComponentes}
bpp(<font_arial>{v}) </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1} \ \ <br>{operación} bpp
(<font_arial>{v}: Nodo) <body>{in1} <br>{para cada} nodo <font_arial>{w} adyacente a <font_arial>{v} <br>{hacer}
<body>{in1} <br>{si} <font_arial>{marca}[<font_arial>{w}] = 0 <br>{entonces} <body>{in1}
<font_arial>{marca}[<font_arial>{w}]:= <font_arial>{numeroComponentes} bpp(<font_arial>{w}) </body>{in1}
<br>{finsi} </body>{in1} </body>{especi} </body>{ejemplo} &nbsp; {Cálculo de componentes en grafos dirigidos}
¿Podemos aplicar para los grafos dirigidos la misma idea que para los no dirigidos? Es decir, ¿bastaría con hacer
una búsqueda primero en profundidad para obtener los componentes fuertemente conexos del grafo? Pues,
desafortunadamente no. Se puede comprobar con un contraejemplo, como el grafo de la figura <label>{fig:compcon3}.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/compcon3.eps} </body>{center} <form>{Componentes fuertemente
conexos. a) Grafo dirigido. b) La búsqueda en profundidad genera solo un árbol, aunque hay cuatro componentes
fuertemente conexos.} <meta>{fig:compcon3} </body>{figure} Claramente, en el grafo de la figura
<label>{fig:compcon3} los componentes fuertemente conexos son cada uno de los nodos por separado. Existe un
camino, por ejemplo, de 1 a 4, y no de 4 a 1. Pero la búsqueda en profundidad genera un solo árbol para todo el
grafo. No obstante, razonando sobre este mismo ejemplo, si la búsqueda primero en profundidad hubiera o hubiese
empezado al revés (primero por el 4, luego el 3, etc.) sí que habríamos obtenido un árbol de expansión por cada
componente fuertemente conexo, que es precisamente lo que buscamos. La conclusión es que tenemos que hacer una
búsqueda en profundidad, pero no en un orden cualquiera. ¿En qué orden? Pues en un orden que garantice que si
desde $v$ se visita $w$, también desde $w$ se puede llegar a $v$. Para conseguirlo, nos basamos en dos búsquedas
en profundidad: en la primera se numeran los nodos, y en la segunda se utiliza esa numeración para hacer el
segundo recorrido. Además, la segunda búsqueda se hace invirtiendo el sentido de las aristas, de manera que si una
búsqueda garantiza los caminos de $v$ a $w$, la otra comprueba también los de $w$ a $v$. En definitiva, el
algoritmo para calcular los componentes fuertemente conexos de un grafo dirigido, $G=(V,A)$, tendría la siguiente
estructura: <body>{enumerate} </font> Realizar una búsqueda primero en profundidad de $G$, numerando los vértices
en el orden de terminación de las llamadas recursivas, es decir, justo antes de finalizar la llamada a
</font></a>{bpp}. Esto es lo que se conoce normalmente como <br>{numeración en orden posterior}. </font> Construir
un nuevo grafo dirigido, $G_R$, invirtiendo las direcciones de los arcos. Es decir, para todo
$<$<bold>n</bold>{v,w}$> </blockquote> A(G)$, tenemos que $<$<bold>n</bold>{v,w}$> </blockquote> A(G_R)$, y
$V(G_R)=V(G)$. </font> Realizar una búsqueda primero en profundidad de $G_R$, partiendo del nodo con numeración
más alta. Si en el recorrido no se visitan todos los nodos, continuar la búsqueda en profundidad a partir del nodo
no visitado con numeración más alta. </font> Cada árbol del bosque de expansión resultante del punto 3, es un
componente fuertemente conexo de $G$. </body>{enumerate} La implementación sería sencilla, sin más que realizar
algunas modificaciones sobre el procedimiento </font></a>{bpp}. En la práctica, en el paso 2 no es necesario
construir otro árbol, sino que bastaría con cambiar: </font></a>{<br>{para cada} nodo <font_arial>{w} adyacente a
<font_arial>{v} <br>{hacer} ...}, por: </font></a>{<br>{para cada} nodo <font_arial>{w} adyacente de
<font_arial>{v} <br>{hacer} ...} En la figura <label>{fig:compcon4} se muestra un ejemplo de aplicación de este
algoritmo. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/compcon4.eps} </body>{center} <form>{Obtención de
los componentes fuertemente conexos. a) Grafo del problema. b) Búsqueda en profundidad del paso 1, con numeración
en orden posterior. c) Grafo invertido, $G_R$. d) Búsqueda en profundidad de $G_R$, del paso 3.}
<meta>{fig:compcon4} </body>{figure} Se puede observar en el ejemplo de la figura <label>{fig:compcon4}, que todo
vértice del grafo $G$ pertenece a algún componente fuertemente conexo. Pero no ocurre lo mismo con las aristas.
Estas aristas --que conectan dos vértices que pertenecen a distintos componentes-- se llaman <br>{arcos de cruce
de componentes}. Utilizando estos arcos de cruce de componentes es posible obtener una representación simplificada
de un grafo dirigido, conocida como grafo reducido. El <br>{grafo reducido} asociado a un grafo dirigido $G$, es
un grafo dirigido en el que cada nodo representa un componente fuertemente conexo de $G$. Además, existirá una
arista $<$<bold>n</bold>{v,w}$>$ en el grafo reducido, si existe una arista entre algunos de los nodos de los
componentes conexos de $G$ correspondientes a $v$ y a $w$. En la figura <label>{fig:compcon5} se muestran dos
ejemplos de grafos reducidos. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/compcon5.eps} </body>{center}
<form>{Grafos reducidos asociados a los grafos dirigidos de las figuras: a) figura <label>{fig:compcon4}, b)
figura <label>{fig:compcon1}.} <meta>{fig:compcon5} </body>{figure} Un grafo reducido sirve para expresar, de
manera simplificada, todos los caminos existentes en el grafo. Por ejemplo, el grafo reducido de la figura
<label>{fig:compcon5}b) nos dice que existen caminos de todos los nodos de </font></a>{\{a, b, h\}} entre sí, de
todos los nodos de </font></a>{\{d, f, g\}} entre sí, y también hay caminos desde los </font></a>{\{a, b, h\}}
hasta los </font></a>{\{d, f, g\}}, pero no al revés. <body>{ejemplo} Comprobar que dentro de un grafo reducido no
pueden existir ciclos. Supongamos, por reducción al absurdo, que existe algún ciclo dentro de un grafo reducido.
Sean los nodos $v$ y $w$ parte de este ciclo. Esto significa que existe un camino de $v$ a $w$ y otro camino de
$w$ a $v$, siguiendo el ciclo. Por lo tanto, todos los nodos de $v$ y los de $w$ están fuertemente conectados, y
deberían estar en el mismo componente fuertemente conexo. Como el grafo reducido representa cada componente
fuertemente conexo con un nodo, no podrían aparecer dos nodos $v$ y $w$ distintos. </body>{ejemplo} <html>{Grafos
dirigidos acíclicos} Un <br>{grafo dirigido acíclico} (<br>{GDA}) no es más que un grafo dirigido y sin ciclos. En
muchas aplicaciones que usan grafos dirigidos, las características del problema obligan --de forma implícita o
explícita-- a que no existan ciclos en el grafo. Por ejemplo, acabamos de ver que el grafo reducido de un grafo
dirigido es siempre un grafo acíclico. El interés de los GDA es que existen ciertos conceptos y problemas que sólo
tienen sentido sobre este tipo de grafos, como la ordenación topológica. En la figura <label>{fig:gda1} se
muestran dos ejemplos de aplicaciones donde aparecen GDA. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/gda1.eps} </body>{center} <form>{Dos aplicaciones que usan GDA. a) Representación de expresiones
aritméticas con subexpresiones comunes, para la expresión: $((a+b)c+((a+b)e)(e+f))((a+b)c)$. b) Grafo de
planificación de tareas. Tareas necesarias para construir una pirámide. A la derecha se indican los meses
previstos para cada tarea.} <meta>{fig:gda1} </body>{figure} <li> </font> <br>{Expresiones aritméticas con
subexpresiones comunes.} Como vimos en el capítulo 4, un árbol puede utilizarse para representar expresiones
aritméticas. Pero si aparecen subexpresiones repetidas dentro del árbol, entonces podemos usar un grafo para
evitar duplicaciones. Por ejemplo, en la figura <label>{fig:gda1}, la expresión $(a+b)$ aparece tres veces pero
sólo se representa una. Si existiera un ciclo, sería imposible evaluar el resultado final de la expresión, habría
recursividad infinita. </font> <br>{Planificación de tareas.} En los grandes sistemas de gestión empresarial, el
desarrollo de un gran proyecto se divide en muchas tareas pequeñas. Existen <br>{precedencias} entre las tareas:
si $a$ precede a $b$, entonces $b$ no puede empezar hasta que haya acabado $a$. Los nodos representan tareas
--cada una de las cuales tiene un tiempo estimado de ejecución-- y cada arista $<$<font_arial>{a,b}$>$ significa
que $a$ precede a $b$. Por ejemplo, en la figura <label>{fig:gda1}b) la tarea ``</font></a>{Pintar pirámide}''
tarda 3 meses, pero sólo puede empezar después de ``</font></a>{Hacer camino}'' y ``</font></a>{Colocar
piedras}''. Si existiera un ciclo sería imposible ejecutar el proyecto. </font> <br>{Prerrequisitos de un plan de
estudios.} En este caso, cada nodo representa una asignatura y una arista indica que para hacer cierta asignatura
antes hay que acabar otra. Esta aplicación es parecida a la anterior. ¿Qué pasaría si para matricularse en AED
antes hay que aprobar Álgebra, pero para matricularse en Álgebra hay que tener aprobada AED? Obviamente, no puede
haber ciclos. </li> En planificación de tareas aparecen cuestiones del tipo: ¿en qué orden se deben ejecutar las
tareas para que se cumplan las precedencias? ¿Qué tareas se pueden ejecutar simultáneamente? ¿Cuánto tiempo puede
tardar como mínimo la ejecución del plan completo? ¿Cuáles son las tarea críticas, es decir,introducción, un grafo
$G=(V, A)$ se dice que es conexo, o que está conectado, si existen caminos entre $v$ y $w$, para todo $v,w
</blockquote> V$. En el caso de los grafos dirigidos añadimos la etiqueta ``fuertemente''. Definimos también un
componente conexo --o <br>{componente fuertemente conexo}, en grafos dirigidos-- como un subgrafo conexo y maximal
de $G$. Obviamente, si un grafo es conexo, entonces sólo tendrá un componente conexo, que será él mismo. Por otro
lado, las que no se pueden retrasar? &nbsp; {Órdenes parciales en conjuntos} El concepto matemático subyacente a
los GDA es la representación de <br>{órdenes parciales} en un conjunto. <body>{definicion} Un <br>{orden parcial}
en un conjunto $S$ es una relación binaria $R$ que cumple las siguientes propiedades: <li> </font> [-]
<br>{Propiedad irreflexiva.} Para todo $a </blockquote> S$, $a~R~a$ es falso. </font> [-] <br>{Propiedad
transitiva.} Para todo $a, b, c </blockquote> S$, si $a~R~b$ y $b~R~c$ entonces $a~R~c$. </li> </body>{definicion}
Por ejemplo, la relación de menor estricto, ``$<$'', en los reales o la inclusión propia, ``$\subset$'', en los
conjuntos son órdenes parciales. En la figura <label>{fig:gda2} se muestra un ejemplo de GDA para representar un
orden parcial. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/gda2.eps} </body>{center}
<form>{Representación de un orden parcial mediante un GDA. Relación ``$\subset$'' en el conjunto de los
subconjuntos de </font></a>{\{1, 2, 3\}}. } <meta>{fig:gda2} </body>{figure} ¿Por qué no pueden existir ciclos en
el grafo asociado a un orden parcial? Si existiera un ciclo de relaciones, por ejemplo que contenga un elemento
$a$, entonces podríamos aplicar la propiedad transitiva y deducir que $a~R~a$, lo cual no es posible. &nbsp;
{Ordenación topológica de un GDA} Sobre los GDA es posible definir un tipo específico de recorrido, conocido como
<br>{recorrido en orden topológico}. En el recorrido en orden topológico, si existe un camino de un nodo $v$ a $w$
entonces $v$ debe visitarse antes que $w$. El recorrido topológico da lugar a la <br>{numeración en orden
topológico}. <body>{definicion} La <br>{numeración en orden topológico} de un GDA, $G=(V,A)$, es una función
$orden: V <symbol> [1..n]$, tal que si $<$<bold>n</bold>{v,w}$> </blockquote> A$, entonces $orden(v) < orden(w)$.
</body>{definicion} La ordenación topológica de un grafo puede tener diferentes utilidades. Por ejemplo, en el GDA
de expresiones aritméticas el orden topológico, recorrido de mayor a menor, indica el orden en el que deben
calcularse las distintas subexpresiones para obtener el resultado final. En el grafo de planificación de tareas,
el orden topológico indica una ejecución secuencial de las tareas que respeta las precedencias. Por ejemplo, un
orden posible sería: </font></a>{Licencia de obras}, </font></a>{Aplanar terreno}, </font></a>{Hacer camino},
</font></a>{Comprar piedras}, </font></a>{Cincelar piedras}, </font></a>{Colocar piedras}, </font></a>{Pintar
pirámide}. Obviamente, la ordenación topológica de un grafo no es única. Un algoritmo sencillo para encontrar una
ordenación topológica consiste en buscar primero un vértice al cual no le apunte ningún arco. Este sería el
primero dentro de la ordenación. Entonces lo visitamos y lo eliminamos junto con todas sus aristas. Después se
aplica la misma estrategia con el grafo restante. Buscamos otro vértice que no reciba aristas, es decir que tenga
grado de entrada cero, lo visitamos y lo borramos. Y así vamos repitiendo hasta visitar todos los nodos del GDA.
Para poder llevar a cabo la idea anterior, necesitamos conocer el grado de entrada de los vértices del grafo;
supondremos que lo tenemos calculado en un array </font></a>{<font_arial>{GradoEnt}}, de tamaño $n$. En cada paso
del algoritmo, seleccionamos un vértice $v$ no visitado</a>{Si no existe ningún vértice con grado de entrada cero,
podemos afirmar que el grafo tiene algún ciclo.} y con </font></a>{<font_arial>{GradoEnt}[$v$] = 0}. Ahora se
actualiza el array </font></a>{<font_arial>{GradoEnt}}, decrementando en uno el grado de entrada de los vértices
adyacentes a $v$, con una iteración del tipo: </font></a>{<br>{para cada} <font_arial>{w} adyacente a
<font_arial>{v} ...} Podemos mejorar el algoritmo si utilizamos una cola de nodos, </font></a>{<font_arial>{C}},
en la que mantengamos en cada momento aquellos vértices con grado cero, pero no seleccionados hasta ahora. De esta
manera, elegir el siguiente nodo a visitar requiere un $O(1)$, y no tenemos que recorrer el array cada vez. Si la
cola está vacía y no hemos seleccionado todos los vértices, el grafo tiene al menos un ciclo. <body>{especi}
<body>{in1} <br>{operación} OrdenaciónTopológica (<font_arial>{GradoEnt}: <br>{array} [1..<font_arial>{n}]
<br>{de} entero; <br>{var} <font_arial>{orden}: <br>{array} [1..<font_arial>{n}] <br>{de} entero) <br>{var}
<font_arial>{C}: Cola[entero] <body>{in1} <font_arial>{C}:= CrearCola <font_arial>{contador}:=1 <br>{para}
<font_arial>{v}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{si} <font_arial>{GradoEnt}[<font_arial>{v}]
= 0 <br>{entonces} <body>{in1} InsCola(<font_arial>{C}, <font_arial>{v}) </body>{in1} <br>{finsi} </body>{in1}
<br>{finpara} <br>{mientras} NO EsVaciaCola(<font_arial>{C}) <br>{hacer} <body>{in1} <font_arial>{v}:=
Cabeza(<font_arial>{C}) Sacar(<font_arial>{C}) <font_arial>{orden}[<font_arial>{v}]:= <font_arial>{contador}
<font_arial>{contador}:= <font_arial>{contador} + 1 <br>{para cada} <font_arial>{w} adyacente a <font_arial>{v}
<br>{hacer} <body>{in1} <font_arial>{GradoEnt}[<font_arial>{w}]:= <font_arial>{GradoEnt}[<font_arial>{w}] - 1
<br>{si} <font_arial>{GradoEnt}[<font_arial>{w}] = 0 <br>{entonces} <body>{in1} InsCola(<font_arial>{C},
<font_arial>{w}) </body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1} <br>{finmientras} <br>{si}
<font_arial>{contador} = <font_arial>{n} <br>{entonces} <body>{in1} <br>{error}(``El grafo tiene un ciclo'')
</font> Buscar un ciclo en $G$ empezando por un vértice $v$ cualquiera. Puede que en este ciclo no todas las
aristas hayan sido visitadas. En ese caso, seguimos con el siguiente punto. </font> Si quedan aristas por visitar,
seleccionar el primer nodo $w$ del ciclo anterior que tenga una arista no visitada. Buscar un ciclo partiendo de
$w$ que pase por aristas no visitadas. </body>{in1} <br>{finsi} </body>{in1} </body>{in1} </body>{especi} En la
figura <label>{fig:gda3} se puede ver un ejemplo de ejecución de este algoritmo. La ordenación topológica de este
grafo no es única. ¿Cómo se puede comprobar? Si en algún paso de ejecución la cola </font></a>{<font_arial>{C}}
contiene más de un vértice, entonces podríamos seguir por cualquiera de ellos. Por ejemplo, cuando
</font></a>{<font_arial>{contador} = 4}, la cola contiene dos nodos. En ese caso la ordenación no es única. En
realidad, en lugar de una cola podríamos usar una pila, una lista o cualquier otro orden de selección.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/gda3.eps} </body>{center} <form>{Ordenación topológica en un
GDA. Arriba: GDA de ejemplo. Abajo: ejecución del algoritmo sobre el ejemplo.} <meta>{fig:gda3} </body>{figure} El
análisis del tiempo de ejecución es muy parecido al que realizamos en los recorridos en profundidad y en anchura.
De esta forma, si medimos el trabajo total realizado tenemos un $O(n^2)$ con matrices de adyacencia, y un $O(n+a)$
con listas de adyacencia. Una manera alternativa de hacer la ordenación topológica es mediante una búsqueda
primero en profundidad, numerando los vértices decrecientemente en orden de terminación de las llamadas
recursivas. Es decir, para el primer nodo que acaba la llamada recursiva a </font></a>{bbp(<font_arial>{v})}
tendríamos $orden[v]=n$, para el siguiente $n-1$, y así sucesivamente. El orden obtenido es un orden topológico
porque un nodo sólo acabará su llamada recursiva cuando todos sus adyacentes hayan sido visitados. <html>{Flujo
máximo en redes} En teoría de grafos, un grafo dirigido con pesos es también conocido como una <br>{red}. En los
problemas de flujo en redes, las aristas representan canales por los que puede circular cierta cosa: datos, agua,
coches, corriente eléctrica, etc. Los pesos de las aristas representan la capacidad máxima de un canal: velocidad
de una conexión, volumen máximo de agua, cantidad máxima de tráfico, voltaje de una línea eléctrica, etc.; aunque
es posible que la cantidad real de flujo sea menor. El <br>{problema del flujo máximo} consiste en lo siguiente:
dado un grafo dirigido con pesos, $G=(V,A,W)$, que representa las capacidades máximas de los canales, un nodo de
inicio $s$ y otro de fin $t$ en $V$, encontrar la cantidad máxima de flujo que puede circular desde $s$ hasta $t$.
En la figura <label>{fig:flujos1} se muestra un ejemplo de problema y la solución. El grafo de la izquierda, $G$,
pintado con líneas continuas, representa las capacidades máximas; sería la entrada del problema. El grafo de la
derecha, $F$, representado con líneas discontinuas, indica los flujos reales; es una posible solución para el
problema. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/flujos1.eps} </body>{center} <form>{Problema de
flujo máximo en redes. a) Grafo de capacidades máximas de los canales. b) Solución del problema, grafo de flujos
reales.} <meta>{fig:flujos1} </body>{figure} La solución del problema debe cumplir las siguientes propiedades:
<li> </font> La suma de los pesos de las aristas que salen de $s$ debe ser igual a la suma de las aristas que
llegan a $t$. Esta cantidad es el <br>{flujo total} entre $s$ y $t$. </font> Para cualquier nodo distinto de $s$ y
de $t$, la suma de las aristas que llegan al nodo debe ser igual a la suma de las aristas que salen al mismo.
</font> Los pesos de las aristas en $F$ no pueden superar los pesos máximos indicados en $G$. Es decir, si
$C_G(a,b)$ es el peso de la arista $<$<bold>n</bold>{a,b}$>$ de $G$ y $C_F(a,b)$ es el peso de la misma arista en
$F$, entonces $C_F(a,b) \leq C_G(a,b)$. </li> Una vez planteado el problema, vamos a estudiar la forma de
resolverlo. En primer lugar propondremos un algoritmo intuitivo, y a continuación analizaremos si garantiza la
solución óptima o no. &nbsp; {Un posible algoritmo para calcular el flujo máximo} La estructura del algoritmo que
lleva a cabo esta idea sería la siguiente: <body>{enumerate} </font> Sea $G=(V,A,C_G)$ el grafo de capacidades
máximas. Inicializar el grafo de flujos reales, $F$, con los mismos nodos y aristas de $G$, pero con pesos 0. Es
decir, $C_F(v,w)=0; ~ \forall <$<bold>n</bold>{v,w}$>~ </blockquote> A$. Este grafo guardará el resultado del
algoritmo. </font> Buscar un camino en $G$, desde $s$ hasta $t$, pasando por aristas cuyo peso sea mayor que 0.
Este camino es denominado <br>{camino creciente}. Supongamos que el camino es $(s, v_1, v_2, ..., v_k, t)$.
Tomamos $m= min\{C_G(s,v_1), C_G(v_1,v_2), ..., C_G(v_k,t)\}$. Es decir, por este camino pueden fluir hasta $m$
unidades de flujo, como máximo. </font> Para cada arista $<$<bold>n</bold>{v,w}$>$ del camino anterior, añadir $m$
al coste de la arista correspondiente en $F$ y quitarlo en $G$. Es decir, $C_F(v, w) = C_F(v, w) + m$; $C_G(v, w)
= C_G(v, w) - m$; para todo $<$<bold>n</bold>{v,w}$>$ del camino del paso 2. </font> Volver al paso 2 mientras
siga existiendo algún camino creciente entre $s$ y $t$ en $G$. </body>{enumerate} Vemos que se cumple únicamente
para el nodo $c$; tiene como hijo el nodo $f$, cuyo </font></a>{<font_arial>{bajo}}[$f$]=5 $\geq$
</font></a>{<font_arial>{nbpp}}[$c$]=5. En consecuencia, $f$ es otro punto de articulación. Todavía nos queda por
determinar la forma de encontrar el camino creciente del paso 2. Una vez más, la búsqueda primero en profundidad
puede sernos de utilidad. Para encontrar un camino creciente, podríamos iniciar una búsqueda en profundidad en $G$
a partir del nodo $s$. Cuando la búsqueda llegue a $t$ ya tenemos un camino de $s$ a $t$</a>{El camino estaría en
la pila de llamadas recursivas. Lo más adecuado sería ir almacenando en un array los nodos que están en la rama
actual de la llamada a </font></a>{bpp}.}. Además, el procedimiento </font></a>{bpp} debería ser modificado para
tener en cuenta sólo las aristas con peso mayor que cero. Por otro lado, está claro que entre $s$ y $t$ puede
haber más de un camino creciente. Esta primera versión del algoritmo indica que se encuentre un camino cualquiera.
El algoritmo será óptimo si, independientemente de los caminos elegidos en el paso 2, siempre encuentra el flujo
máximo. Vamos a ver que no siempre ocurre así. <body>{ejemplo} <meta>{eje:flujomax1} Vamos a aplicar la primera
versión del algoritmo del flujo máximo sobre el grafo $G$ de la figura <label>{fig:flujos1}a). En la figura
<label>{fig:flujos2} se muestra una ejecución posible del algoritmo, donde no se alcanza la solución óptima.
<body>{figure}[!ht]ritmo es no determinista: en el paso 2 se pueden elegir varios caminos y, dependiendo de cuál
se coja, el algoritmo alcanza la solución óptima o no. Para solucionar el problema podemos hacer una pequeña
modificación en el algoritmo. El sentido de esta modificación es que si se coge un camino, pero que luego resulta
ser una mala decisión, se pueda <br>{deshacer el flujo} enviado <body>{center} </tr></html>{cap5/flujos2.eps}
</body>{center} <form>{Primera versión del algoritmo de flujo máximo en redes. a) Grafo del problema, $G$. b)
Grafo de diferencia ahora es que lo que se marca como visitado no son los nodos sino las aristas. <body>{ejemplo}
Vamos a aplicar el algoritmo para calcular el circuito de Euler para el grafo de la figura <label>{fig:euler1}.
Supongamos que empezamos por el nodo 1. Podemos tener algo como lo siguiente: Paso 1. Encontramos el ciclo: $C=(1,
2, 5, 7, 6, 3, 1)$. Paso 3. Unimos el ciclo $C$ con el $D$, Obtenemos: $C= (1, 2, 3, 4, 5, 6, 4, 2, 5, 7, 6, 3,
1)$. Todas las aristas están ya visitadas, por lo que acaba el algoritmo. </body>{ejemplo} <title>Otros Además de
los problemas que hemos estudiado en los apartados anteriores, existen otros muchos tipos de problemas clásicos en
teoría de grafos. Todos ellos aparecen como resultado de modelar un problema de la vida real a través de grafos.
Así que disponer de flujos $F$ inicial. c) Grafo $G$ después de quitar el camino $(s,c,b,t)$. d) Grafo de flujos
después de añadir el mismo camino.} <meta>{fig:flujos2} </body>{figure} En la primera ejecución del paso 2, se
encuentra el camino $(s,c,b,t)$. Los costes de las aristas son: 4, 4, 4; así que $m=4$. Esta cantidad se añade en
$F$ (figura <label>{fig:flujos2}d) y se quita de $G$ (figura <label>{fig:flujos2}c). Si intentamos buscar otro
camino entre $s$ y $t$, en el grafo de la figura <label>{fig:flujos2}c), que pase por aristas con peso mayor que
cero, vemos que no existe ninguno. Por lo tanto, el algoritmo acabaría. El resultado del algoritmo es que el flujo
total encontrado es 4. En consecuencia, el algoritmo no encuentra el óptimo, que como vimos en la figura
<label>{fig:flujos1} es 6 unidades de flujo. No obstante, si los caminos hubieran sido elegidos en otro orden sí
que se habría obtenido el óptimo. En concreto, se puede comprobar que el resultado de la figura
<label>{fig:flujos1} se alcanzaría si seleccionamos los siguientes caminos, por orden: $(s,a,b,t)$ con peso 2;
$(s,c,d,t)$ con peso 2; $(s,c,d,b,t)$ con peso 1; $(s,c,b,t)$ con peso 1. </body>{ejemplo} &nbsp; {Algoritmo de
flujo máximo deshaciendo caminos} La primera versión del algo por ese camino. tengan distinto formato o incluso
que los objetos buscados sean caras humanas. Un posible modelo sería un problema de patrones --patrones como los
de un sastre-- que admiten cierta variabilidad: se pueden mover, estirar, cambiar el tamaño, rotar, etc. El
problema consistiría en buscar esos patrones en las imágenes, en todos los sitios que se pueda. Grosso modo, un
algoritmo podría consistir en generar todas las posibles colocaciones, rotaciones y tamaños de los patrones y
quedarnos con las que ``encajen'' con lo que hay En particular, la modificación afecta a la forma de actualizar
$C_G$ dentro del paso 3. Cada vez que encontramos un camino creciente, quitamos $m$ unidades de flujo de $G$ y las
ponemos en $F$. Ahora, además, vamos a indicar en $G$ que se pueden deshacer $m$ unidades de flujo a través de las
aristas del camino. El flujo que se deshace tendrá el sentido opuesto al de añadir; es decir, si se añade $m$
unidades en $<$<bold>n</bold>{v,w}$>$ en $F$, entonces se quitan $m$ de $<$<bold>n</bold>{v,w}$>$ en $G$ y se
añaden $m$ unidades de deshacer para la arista $<$<bold>n</bold>{w,v}$>$ en $G$. En definitiva, este cambio sólo
implica modificaciones dentro del paso 3 del algoritmo, que ahora debería decir: <body>{enumerate} </font> [3]
Para cada arista $<$<bold>n</bold>{v,w}$>$ del camino anterior, añadir $m$ al coste de la arista correspondiente
en $F$, quitarlo en $G$ y ponerlo en $G$ en sentido contrario. Es decir, $C_F(v, w) = C_F(v, w) + m$; $C_G(v, w) =
C_G(v, w) - m$; $C_G(w, v) = C_G(w, v) + m$ para todo $<$<bold>n</bold>{v,w}$>$ del camino del paso 2.
</body>{enumerate} Hay que tener en cuenta que aquí estamos suponiendo que el peso de una arista inexistente es 0.
De esta forma, cuando sumamos $m$ a $C_G(w, v)$, pero $<$<bold>n</bold>{v,w}$>$ no está en $G$, sería equivalente
a crear una nueva arista con peso $m$. Esta nueva versión del algoritmo no deja de ser no determinista, pero
garantiza siempre la solución óptima. Aunque no lo vamos a demostrar, vamos a ver que se resuelve correctamente el
problema que vimos en el ejemplo <label>{eje:flujomax1}. <body>{ejemplo} <meta>{eje:flujomax2} Vamos a aplicar la
segunda versión del algoritmo del flujo máximo --la que permite deshacer caminos-- sobre el grafo $G$ de la figura
<label>{fig:flujos1}a). Un posible resultado del algoritmo se muestra en la figura <label>{fig:flujos3}.
<body>{figure}[!ht] <body>{center} </tr></html>{cap5/flujos3.eps} </body>{center} <form>{Segunda versión del
algoritmo de flujo máximo en redes. a) Grafo del problema, $G$. b) Grafo de flujos $F$ inicial. c),d) Grafos $G$ y
$F$, después de encontrar el camino $(s,c,b,t)$. e),f) Grafo $G$ y $F$, después de encontrar el camino
$(s,a,b,c,d,t)$.} <meta>{fig:flujos3} </body>{figure} Igual que en el ejemplo <label>{eje:flujomax1}, consideramos
que en la primera ejecución del paso 2 se encuentra el camino $(s,c,b,t)$, con $m=4$. Esta cantidad se añade en
$F$ (figura <label>{fig:flujos3}d). Ahora, en $G$ se quita esa cantidad en sentido directo y se añade en sentido
contrario (figura <label>{fig:flujos3}c). A continuación podemos encontrar un nuevo camino, que pasa por la arista
de ``deshacer'' $<$<bold>n</bold>{b,c}$>$. El camino es $(s,a,b,c,d,t)$, con pesos: 5, 2, 4, 3, 2. Por lo tanto,
$m=2$. Se añade a $F$</a>{Hay que notar un detalle sutil. Cuando en el grafo de la figura <label>{fig:flujos3}d)
se añade el flujo de ``deshacer'' entre $b$ y $c$, no se añade realmente 2 a $C_F(b,c)$, sino que se resta 2 de
$C_F(c,b)$. ¿Por qué?} (figura <label>{fig:flujos3}f) y se actualiza $G$ (figura <label>{fig:flujos3}e). En el
siguiente paso, ya no existe ningún camino creciente, luego acaba el algoritmo. Si comparamos la solución obtenida
con la mostrada en la figura <label>{fig:flujos1}, vemos que no coinciden. No obstante, ambas tienen el mismo
valor de flujo total, 6, y ambas son óptimas. En perfectamente posible, como en este ejemplo, que la solución
óptima no sea única. </body>{ejemplo} <title>Algoritmos sobre grafos no dirigidos} En esta sección plantearemos
dos problemas específicos de grafos no dirigidos: la búsqueda de los puntos de articulación y los circuitos de
Euler. Vamos a ver que ambos problemas se pueden resolver utilizando como herramienta la búsqueda primero en
profundidad. <html>{Puntos de articulación y componentes biconexos} Como sabemos, un grafo no dirigido se dice que
es conexo si existen caminos entre todos sus nodos. Pero en muchas aplicaciones se requiere un nivel más de
conexión; se necesita no sólo que los nodos estén conectados sino que si falla algún nodo o enlace, los nodos
sigan conectados. Buscamos lo que se podría denominar </label>{tolerancia a fallos}. En la figura
<label>{fig:articul1} se muestran dos ejemplos de aplicación. El grafo de la figura <label>{fig:articul1}a)
muestra las estrategias de pase del balón de un equipo de fútbol; la figura <label>{fig:articul1}b) muestra una
red de ordenadores y las conexiones entre los mismos. Como ya hemos visto, los algoritmos junto con las
estructuras de datos constituyen los dos elementos imprescindibles en el proceso de resolución de problemas. Los
primeros definen el componente manipulador y los segundos el componente almacenado, y se combinan estrechamente
para crear soluciones a los problemas. No está de más recordar que la historia de los algoritmos es mucho anterior
a la aparición de los ordenadores. De hecho, podríamos datar la aparición de los algoritmos al primer momento en
que los seres humanos se plantearon resolver problemas de forma genérica. Históricamente uno de los primeros
algoritmos inventados, para la resolución de problemas de tipo matemático, es el algoritmo de \textbf{Euclides} de
Alejandría, Egipto, propuesto alrededor del año 300 a.C. Euclides propone el siguiente método para calcular el
máximo común divisor de dos números enteros. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/articul1.eps}
</body>{center} <form>{Ejemplos de grafos no dirigidos. a) Jugadores de un equipo de fútbol (nodos) y estrategias
de pase del balón (aristas). b) Red de ordenadores.} <meta>{fig:articul1} </body>{figure} En este tipo de
aplicaciones surge el estudio de los puntos de articulación y los componentes biconexos. <body>{definicion} Sea un
grafo no dirigido y conexo, $G=(V, A)$. Un <br>{punto de articulación} es un vértice $v$ tal que cuando se elimina
de $G$ junto con todas las aristas incidentes en él, se divide una componente conexa de $G$ en dos o más.
</body>{definicion} El punto de articulación es un nodo </label>{crítico} del grafo, en el sentido de que si falla
tendremos graves problemas. Por ejemplo, en la figura <label>{fig:articul1}a) el jugador 7 es un punto de
articulación; si conseguimos eliminarlo cortaremos la circulación del balón entre la defensa y la delantera. En la
figura <label>{fig:articul1}b) los ordenadores </font></a>{a} y </font></a>{c} son puntos de articulación; si
cualquiera de ellos cae, quedarán trozos de red incomunicados. Un grafo no dirigido se dice que es <br>{biconexo}
si no tiene puntos de articulación. En los anteriores apartados hemos hablado informalmente de grafos más o menos
conectados. Podemos definir el concepto de conectividad de un grafo de la siguiente forma. <body>{definicion} Un
grafo no dirigido se dice que tiene <br>{conectividad $k$} si la eliminación de $k-1$ vértices cualesquiera, junto
con las aristas incidentes en ellos, no desconecta el grafo resultante. </body>{definicion} De acuerdo con la
definición, un grafo tiene conectividad 2 o más si y sólo si no tiene puntos de articulación, es decir, si es
biconexo. Por ejemplo, los grafos de la figura <label>{fig:articul1} no son biconexos, por lo que su conectividad
es 1. Cuanto mayor sea la conectividad del grafo, más fácil será que </label>{sobreviva} al fallo de alguno de sus
vértices. Por otro lado, según la definición, si un grafo tienen conectividad $k$, también tendrá conectividad
$k-1$, $k-2$, ..., 1. <body>{ejemplo} ¿Cuánto es la máxima conectividad posible de un grafo? ¿A qué grafo
corresponde? ¿Cuántas aristas debe tener un grafo como mínimo para ser biconexo? La máxima conectividad posible
sería la de un grafo completo. Podemos eliminar todos los vértices sin desconectarlo. Sólo cuando eliminemos todos
los nodos conseguimos suprimir un componente conexo. Podemos decir que el grafo completo tiene conectividad $n$,
siendo $n$ el número de nodos del grafo. En cuanto al mínimo número de aristas, sabemos que un grafo con forma de
árbol es el menor grafo conexo posible. Un grafo de ese tipo tiene $n-1$ aristas, pero no es biconexo. Todos los
nodos, excepto las hojas, serían puntos de articulación. Consideremos un grafo con forma de anillo. Tiene $n$
aristas y es biconexo, ya que no tiene puntos de articulación. Por lo tanto, el mínimo número de aristas para un
grafo biconexo sería $n$. Ojo, esto no garantiza que cualquier grafo no dirigido con $n$ aristas sea biconexo.
</body>{ejemplo} &nbsp; {Algoritmo para calcular los puntos de articulación} A falta de una idea mejor, una
posible solución para calcular los puntos de articulación de un grafo podría ser la siguiente: eliminar los
vértices del grafo uno por uno; para cada nodo eliminado, comprobar si el grafo resultante sigue siendo conexo o
no; en caso negativo, tenemos un punto de articulación. La comprobación de si el grafo resultante es conexo se
podría hacer con una búsqueda primero en profundidad. En consecuencia, el tiempo de esta solución sería $O(n^3)$
con matrices de adyacencia y $O(n~(a+n))$ con listas. Pero vamos a ver que el problema se puede resolver con una
simple búsqueda en profundidad. Supongamos que hacemos la búsqueda en profundidad de un grafo no dirigido y
conexo, como el de la figura <label>{fig:articul1}b). Obtenemos un árbol abarcador en profundidad, como el
mostrado en la figura <label>{fig:articul2}. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/articul2.eps}
</body>{center} <form>{Caminos alternativos. a) Árbol de expansión en profundidad del grafo de la figura
<label>{fig:articul1}b). b) Si eliminamos el nodo </font></a>{b}, existe para </font></a>{d} y para </font></a>{e}
un camino alternativo para llegar a la raíz. Conclusión: </font></a>{b} no es punto de articulación.}Pero, ¿cuál
es el objetivo último de la algorítmica?, ¿qué es lo que motiva su estudio? El objetivo último es dado un problema
concreto ser capaz de resolverlo de la mejor forma <meta>{fig:articul2} </body>{figure} En el resultado aparecen
dos tipos de arcos: los del árbol y los que no son del árbol, que serán de avance/retroceso. Podemos interpretar
que tenemos dos tipos de caminos entre los nodos: los caminos a través del árbol, hacia los padres, y los caminos
moviéndonos a través de los arcos de retroceso. Los primeros, a través del árbol, siempre existirán; los segundos,
a través de arcos de retroceso, representan caminos </label>{alternativos}. Decimos que son alternativos en el
sentido de que si eliminamos un nodo en el camino del consistirá en moverse a través de un arco de retroceso, o
bien hacia abajo en el árbol y luego hacia arriba por un arco de retroceso. En la figura <label>{fig:articul2}b)
se muestra un ejemplo. Tendremos un punto de articulación si, al eliminar un nodo, alguno de sus hijos no tiene un
camino alternativo para llegar más arriba del nodo eliminado. Es decir, $v$ será un punto de articulación si tiene
un hijo tal que su valor de </font></a>{<font_arial>{bajo}} es menor o igual que el número de búsqueda en
profundidad de $v$. La condición es distinta para la raíz; será punto de articulación si tiene dos o más hijos.
Como ya vimos, no pueden haber arcos de cruce, por lo que si tiene dos o más hijos estos sólo se pueden comunicar
a través de la raíz. problemas con grafos} En definitiva, el <br>{algoritmo para calcular los puntos de
articulación} de un grafo no dirigido tendría la siguiente estructura: del pasado siglo XX. Actualmente,
entendemos la \textbf{algorítmica} como la disciplina, dentro del ámbito de la informática, que estudia técnicas
para construir algoritmos eficientes y técnicas para medir la eficiencia de los algoritmos. En consecuencia, la
algorítmica consta de dos grandes áreas de estudio: el análisis y el diseño de algoritmos. posible, de forma
rápida, corta, elegante y fácil de programar. Y recordemos que en esta resolución entran también en juego las
estructuras de datos, que son manejadas por los algoritmos. En definitiva, todos los ejemplos, técnicas, métodos y
esquemas que vamos a <body>{enumerate} </font> Realizar una búsqueda primero en profundidad, numerando los nodos
en el orden en que son recorridos. Supongamos que guardamos en el array </font></a>{<font_arial>{nbpp}:
<br>{array} [1..<font_arial>{n}] <br>{de} entero}, el orden en que es visitado cada nodo. </font> Calcular los
valores </font></a>{<font_arial>{bajo}[<font_arial>{v}]} para cada nodo visitado, según la fórmula:\\
</font></a>{<font_arial>{bajo}[<font_arial>{v}]}:= mínimo \{</font></a>{<font_arial>{nbpp}[<font_arial>{v}]};\\
</a>*{5em} </font></a>{<font_arial>{nbpp}[<font_arial>{z}]} $|$ para todo </font></a>{<font_arial>{z}} tal que
existaPaso 2. No todas las aristas están visitadas. El primer nodo con una arista no visitada es el 2. Encontramos
el siguiente ciclo: $D= (2, 3, 4, 2)$. Paso 3. Unimos los ciclos $C$ y $D$. Lo que hacemos es, dentro de $C$ en el
lugar donde aparece 2 sustituirlo por $D$. El resultado es: $C= (1, 2, 3, 4, 2, 5, 7, 6, 3, 1)$. Paso 2. No todas
las aristas están visitadas, el primer nodo es 4. Encontramos el ciclo: $D= (4, 5, 6, 4)$. Si bien, como hemos
visto, la historia de los algoritmos se remonta muy atrás, el estudio de los algoritmos no se concibió como una
disciplina propia hasta bien entrada la mitad estudiar tienen como finalidad última servir de herramientas útiles
en el momento de afrontar la resolución de un problema completamente nuevo y desconocido. un arco de retroceso
(</font></a>{<font_arial>{z},<font_arial>{v}}); \\ </a>*{5em} </font></a>{<font_arial>{bajo}[<font_arial>{y}]} $|$
para todo </font></a>{<font_arial>{y}} hijo de </font></a>{<font_arial>{v}} en el árbol de expansión\} </font> La
raíz del árbol es un punto de articulación si y sólo si tiene dos o más hijos en el árbol de expansión en
profundidad. </font> Un nodo </font></a>{<font_arial>{v}}, distinto de la raíz, es un punto de articulación si y
sólo si tiene algún hijo </font></a>{<font_arial>{w}} en el árbol tal que
</font></a>{<font_arial>{bajo}[<font_arial>{w}]} $\geq$ </font></a>{<font_arial>{nbpp}[<font_arial>{v}]}.
</body>{enumerate} Realmente, el cálculo de los valores de </font></a>{<font_arial>{bajo}} y la comprobación de
las condiciones no se deben hacer como pasos separados, sino dentro del mismo procedimiento de </font></a>{bpp}.
Como los cálculos añadidos se pueden hacer en tiempo constante, el orden de aplicación de este algoritmo, para el
mismo grafo de la figura <label>{fig:articul1}a). <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/articul3.eps} </body>{center} <form>{Búsqueda de los puntos de articulación. a) Grafo no
dirigido. b) Aplicación del algoritmo. Se indican los valores de </font></a>{<font_arial>{bajo}} y
</font></a>{<font_arial>{nbpp}}.} <meta>{fig:articul3} </body>{figure} ¿Cuáles son los puntos de articulación del
ejemplo de la figura <label>{fig:articul3}? Para la raíz, $a$, se cumple la condición del punto 3, puesto que
tiene dos hijos. Por lo tanto, $a$ es un punto de articulación. Para los demás nodos, tenemos que comprobar la
condición del punto 4. </body>{ejemplo} &nbsp; {Componentes biconexos} La definición de componente biconexo es
similar a la de componente conexo. Un <br>{componente biconexo} de un grafo $G$ es un subgrafo biconexo y maximal
de $G$. Si $G$ es de por sí biconexo, entonces tendrá un sólo componente biconexo. Si $G$ tiene puntos de
articulación, entonces aparecerán distintos componentes biconexos. ¿Cómo encontrarlos? En primer lugar, deberíamos
calcular los puntos de articulación de $G$. Después, el algoritmo sería similar al cálculo de los componentes
conexos que vimos en el ejemplo <label>{eje:compoconexos}. Recordemos que este algoritmo se basaba en una simple
búsqueda primero en profundidad. La única diferencia es que no se deberían hacer llamadas recursivas al llegar a
un nodo que sea punto de articulación. En la figura <label>{fig:articul4} se muestran los componentes biconexos
del grafo del ejemplo <label>{eje:puntarticul}. Se puede ver que algunos nodos están en más de un componente
biconexo. Esto ocurrirá, precisamente, para los nodos que sean puntos de articulación. <body>{figure}[!ht]
<body>{center} </tr></html>{cap5/articul4.eps} </body>{center} <form>{Componentes biconexos del grafo del  El
problema es: dada una imagen decir dónde se encuentran los objetos. Para resolverlo creamos un grafo a partir de
la imagen, donde los vértices son puntos del dibujo y las aristas del grafo son líneas del dibujo. En la figura
<label>{fig:isomorfo2} se muestra un ejemplo con dos modelos de poliedros (figuras <label>{fig:isomorfo2}a) y b) y
una escena para localizar los modelos (figura <label>{fig:isomorfo2}c). ¿Cómo resolver el problema
algorítmicamente? <body>{figure}[!ht] <body>{center} </tr></html>{cap5/isomorfo2.eps} </body>{center}
<form>{Aplicación del isomorfismo de grafos. a),b) Modelos de grafo asociados a dos poliedros. c) Grafo extraído
de un dibujo de líneas.} <meta>{fig:isomorfo2} </body>{figure} En primer lugar, podríamos separar el grafo del
dibujo en sus componentes conexos. Idealmente, cada componente debería ser isomorfo a algún grafo del modelo.
Pero, puesto que puede haber ruido, imperfecciones o solapamientos, lo que tenemos realmente es un problema de
subisomorfismo. Por ejemplo, de los tres componente de la figura <label>{fig:isomorfo2}c), en uno de ellos podemos
encontrar un isomorfismo con la figura denominada <bold>n</bold>{Tienda}, en otro encontramos dos subisomorfismos
con <bold>n</bold>{Tienda} y con <bold>n</bold>{Cubo}, y en el tercero no hay ningún isomorfismo adecuado.
</body>{ejemplo} <body>{ejercicios} <title>Ejercicios resueltos} <body>{problema} <meta>{eje:graf1} El grafo de la
figura <label>{fig:ejer51} representa una red de ordenadores, con enlaces entre los mismos. Todos ellos se pueden
comunicar entre sí, directamente o a través de otros. Encontrar los ordenadores críticos, es decir los que no
pueden fallar para que todos los ordenadores sigan estando conectados. ¿Es posible añadir algún enlace para que
dejen de existir estos nodos críticos? </table> <body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejer51.eps}
</body>{center} <form>{Red de ordenadores del ejercicio <label>{eje:graf1}.} <meta>{fig:ejer51} </body>{figure}
<label>{fig:colores}b) y <label>{fig:colores}c) son dos posibles coloraciones del grafo. La coloración de la
figura <label>{fig:colores}c) utiliza menos colores, y se puede comprobar que es la solución óptima de este
ejemplo. programación dinámica no se utiliza la recursividad de forma directa. En su lugar, se resuelven primero
los problemas de tamaño pequeño, anotando la solución en una tabla. Usando las soluciones de la tabla, vamos
avanzando hacia problemas cada vez más grandes, <p><br>{Solución.} Claramente, tenemos un problema de puntos de
articulación. Los puntos de ar\-ti\-cu\-la\-ción del grafo serán los nodos que no pueden fallar para que la red
siga conectada. Aplicando el algoritmo obtenemos las numeraciones de </font></a>{nbpp} y </font></a>{bajo}
mostradas en la figura <label>{fig:ejer52}. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejer52.eps}
</body>{center} <form>{Obtención de los puntos de articulación del grafo de la figura <label>{fig:ejer51}.}
<meta>{fig:ejer52} </body>{figure} Una vez con este resultado, aplicamos las dos condiciones del algoritmo para
encontrar los puntos de articulación: <li> </font> La raíz, </font></a>{a}, es un punto de articulación porque
tiene 3 hijos. </font> El nodo </font></a>{b} es un punto de articulación porque tiene un hijo, </font></a>{d},
con </font></a>{bajo[d] = 3 $\geq$ 2 = nbpp[b]}. </font> El nodo </font></a>{d} es un punto de articulación porque
tiene un hijo, </font></a>{f}, con </font></a>{bajo[f] = 3 $\geq$ 3 = nbpp[d]}. </font> El nodo </font></a>{j} es
un punto de articulación porque tiene un hijo, </font></a>{c}, con </font></a>{bajo[c] = 8 $\geq$ 8 = nbpp[j]}.
</li> Para hacer que dejen de haber puntos críticos, debemos añadir aristas de forma que se eliminen los puntos de
articulación. Si nos fijamos en la figura <label>{fig:ejer52}, la eliminación de </font></a>{b} y de
</font></a>{d} provoca que </font></a>{f} y </font></a>{g} queden aislados del resto, aunque comunicados entre sí;
la eliminación de </font></a>{j} aísla a </font></a>{c}, </font></a>{i} y </font></a>{k}; y de los restantes la
eliminación de </font></a>{a} desconectaría a </font></a>{h} y </font></a>{e} de los demás. Estos grupos de nodos
están en componentes biconexos distintos. Si añadimos ciertas aristas entre ellos, podemos eliminar los puntos de
articulación. Por ejemplo, si añadimos las aristas </font></a>{(g,e)} y </font></a>{(h,c)}, el grafo no tendría
puntos de articulación. Por lo tanto, sería un grafo biconexo. <body>{problema} Dado un grafo con pesos, dirigido
o no dirigido, puede que el camino mínimo entre dos nodos $v$ y $w$ no sea único, sino que existan varios.
Modificar los algoritmos de Dijkstra y de Floyd para que, además de calcular los caminos mínimos, también calculen
el número de caminos mínimos distintos existente entre dos nodos. </table> <p><br>{Solución.} Para calcular el
número de caminos mínimos distintos, en el algoritmo de Dijkstra usaremos un array </font></a>{<font_arial>{NC}:
<br>{array} [2..<font_arial>{n}] <br>{de} entero}. Inicialmente, los caminos especiales del algoritmo de Dijkstra
son los caminos directos, así que sólo existe un camino mínimo. Por lo tanto, </font></a>{<font_arial>{NC}} se
inicializaría a 1. <body>{especi} <body>{in1} <br>{para} <font_arial>{i}:= 2, ..., <font_arial>{n} <br>{hacer}
<body>{in1} <font_arial>{NC}[<font_arial>{i}]:= 1 <font_arial>{D}[<font_arial>{i}]:= <font_arial>{C}[1,
<font_arial>{i}] ... </body>{in1} <br>{finpara} </body>{in1} </body>{especi} Por otro lado, tenemos la
actualización del algoritmo de Dijkstra. Cuando añadidos un nuevo nodo </font></a>{<font_arial>{v}}, comprobamos
todos los </font></a>{<font_arial>{w}} adyacentes a </font></a>{<font_arial>{v}}. Tenemos tres posibilidades: <li>
</font> Si </font></a>{<font_arial>{D}[<font_arial>{w}] $<$ (<font_arial>{D}[<font_arial>{v}] +
<font_arial>{C}[<font_arial>{v}, <font_arial>{w}])}, el camino mínimo de </font></a>{<font_arial>{w}} no se
modifica. </font> Si </font></a>{<font_arial>{D}[<font_arial>{w}] $=$ (<font_arial>{D}[<font_arial>{v}] +
<font_arial>{C}[<font_arial>{v}, <font_arial>{w}])}, tenemos varios caminos mínimos más para
</font></a>{<font_arial>{w}}. ¿Cuántos más? Pues tantos como hayan para </font></a>{<font_arial>{v}}. Es decir:
</font></a>{<font_arial>{NC}[<font_arial>{w}]:= <font_arial>{NC}[<font_arial>{w}] +
<font_arial>{NC}[<font_arial>{v}]}. </font> Si </font></a>{<font_arial>{D}[<font_arial>{w}] $>$
(<font_arial>{D}[<font_arial>{v}] + <font_arial>{C}[<font_arial>{v}, <font_arial>{w}])}, existe un nuevo camino
mínimo más para </font></a>{<font_arial>{w}}. Habrán tantos caminos como hayan para </font></a>{<font_arial>{v}}.
Es decir: </font></a>{<font_arial>{NC}[<font_arial>{w}]:= <font_arial>{NC}[<font_arial>{v}]}. </li> Por lo tanto,
el algoritmo de Dijkstra modificado diría: <body>{especi} <body>{in1} <br>{para} <font_arial>{i}:= 2, ...,
<font_arial>{n} <br>{hacer} <body>{in1} <font_arial>{v}:= vértice con Miembro(<font_arial>{T},
<font_arial>{v})=verdadero y <font_arial>{D}[<font_arial>{v}] mínimo Suprime(<font_arial>{T}, <font_arial>{v})
<br>{para cada} nodo <font_arial>{w} adyacente a <font_arial>{v} <br>{hacer} <body>{in1} <br>{si}
Miembro(<font_arial>{T}, <font_arial>{w}) <br>{entonces} <body>{in1} <br>{si} (<font_arial>{D}[<font_arial>{v}] +
<font_arial>{C}[<font_arial>{v}, <font_arial>{w}]) $<$ <font_arial>{D}[<font_arial>{w}] <br>{entonces} <body>{in1}
<font_arial>{D}[<font_arial>{w}]:= <font_arial>{D}[<font_arial>{v}] + <font_arial>{C}[<font_arial>{v},
<font_arial>{w}] <table> Una raíz de un GDA es un vértice $r$ tal que todos los nodos del grafo pueden alcanzarse
desde $r$, es decir, existen caminos entre $r$ y el resto de nodos. Escribir un procedimiento para determinar si
un GDA posee una raíz y, en ese caso, encuentre cuál es. </table> <font_arial>{P}[<font_arial>{w}]:=
<font_arial>{v} <font_arial>{NC}[<font_arial>{w}]:= <font_arial>{NC}[<font_arial>{v}] </body>{in1} <br>{sino si}
(<font_arial>{D}[<font_arial>{v}] + <font_arial>{C}[<font_arial>{v}, <font_arial>{w}]) =
<font_arial>{D}[<font_arial>{w}] <br>{entonces} <body>{in1} <font_arial>{NC}[<font_arial>{w}]:=
<font_arial>{NC}[<font_arial>{w}] + <font_arial>{NC}[<font_arial>{v}] </body>{in1} <br>{finsi} </body>{in1}<table>
Demostrar que todo árbol es un grafo bipartido. </table> <br>{finsi} </body>{in1} <br>{finpara} </body>{in1}
<br>{finpara} </body>{in1} </body>{especi} <table> Demostrar que el grafo reducido de un grafo dirigido $G$
cualquiera --el que representa cada componente fuertemente conexo de $G$ con un nodo-- es siempre un GDA. </table>
<table> siguientes tipos de grafos decir si son biconexos o no, y cuál es su conectividad: a) grafo con estructura
de anillo; b) grafo con estructura de árbol; c) grafo completo con $n$ nodos. </table> En cuanto al algoritmo de
Suponer que estamos trabajando con GDA. ¿Es posible mejorar la eficiencia obtenida con el algoritmo de Dijkstra
para este tipo de grafos? ¿Cómo sería la modificación de este algoritmo para conseguir la mejora? Pista: hacer uso
de la ordenación topológica para seleccionar los nodos entre los candidatos. </table> <table> Para los Floyd, en
este caso el resultado debería ser una matriz </font></a>{<font_arial>{NC}: <br>{array} [1..<font_arial>{n},
1..<font_arial>{n}] <br>{de} entero}. Igual que antes, la inicialización sería
</font></a>{<font_arial>{NC}[<font_arial>{v}, <font_arial>{w}]:= 1}, para todo </font></a>{<font_arial>{v}} y
</font></a>{<font_arial>{w}}. Dentro del paso de pivotaje sobre un </font></a>{<font_arial>{k}}, si el camino
pasando por </font></a>{<font_arial>{k}} tiene menor coste que </font></a>{<font_arial>{D}[<font_arial>{i},
<font_arial>{j}]}, entonces tenemos los caminos mínimos existentes pasando por </font></a>{<font_arial>{k}}. Estos
caminos serán tantos como: </font></a>{<font_arial>{NC}[<font_arial>{i},
<font_arial>{k}]*<font_arial>{NC}[<font_arial>{k}, <font_arial>{j}]}. Si el camino pasando por
</font></a>{<font_arial>{k}} tiene igual coste que </font></a>{<font_arial>{D}[<font_arial>{i}, <font_arial>{j}]},
entonces debemos añadir esos caminos mínimos a </font></a>{<font_arial>{NC}[<font_arial>{i}, <font_arial>{k}]}.
Por lo tanto, el bucle principal del algoritmo de Floyd modificado sería el siguiente: <body>{especi} <body>{in1}
<br>{para} <font_arial>{k}:= 1, ..., <font_arial>{n} <br>{hacer} <body>{in1} <br>{para} <font_arial>{i}:= 1, ...,
<font_arial>{n} <br>{hacer} <body>{in1} <br>{para} <font_arial>{j}:= 1, ..., <font_arial>{n} <br>{hacer}
<body>{in1} <br>{si} <font_arial>{D}[<font_arial>{i}, <font_arial>{j}] $<$ <font_arial>{D}[<font_arial>{i},
<font_arial>{k}]+<font_arial>{D}[<font_arial>{k}, <font_arial>{j}] <br>{entonces} <font_arial>{D}[<font_arial>{i},
<font_arial>{k}]+<font_arial>{D}[<font_arial>{k}, <font_arial>{j}] <br>{entonces} <body>{in1} </br>{NC}[</br>{i},
</br>{j}]:= </br>{NC}[</br>{i}, </br>{j}] + </br>{NC}[</br>{i}, </br>{k}]*</br>{NC}[</br>{k}, </br>{j}]
</body>{in1} <br>{finsi} </body>{in1} <br>{finpara} </body>{in1} <br>{finpara} </body>{in1} <br>{finpara}
</body>{in1} </body>{especi} <body>{in1} </br>{TiempoMinimo}:= min(</br>{TiempoMinimo}, </br>{C}[</br>{i},
</br>{j}]) </body>{in1} <br>{finpara} <br>{si} </br>{TiempoMinimo} = </br>{tmax} <br>{entonces} <body>{in1}
</br>{RatonesQueSalen}:= </br>{RatonesQueSalen} + 1 </body>{in1} <br>{finsi} <body>{problema} <meta>{eje:graf2} En
la figura <label>{fig:ejer53} se representa un plan de estudios. Los nodos indican las asignaturas del plan. Las
aristas indican los prerequisitos para realizar ciertas asignaturas. Es decir, una arista
$<$<bold>n</bold>{v,w}$>$ indica que para matricularse en $w$ hay que tener aprobada $v$. Encontrar un posible
orden secuencial para realizar las asignaturas del plan. El orden obtenido ¿es único? </table> <body>{figure}[!ht]
<body>{center} </tr></html>{cap5/ejer53.eps} </body>{center} <form>{Grafo de prerequisitos de un plan de estudios
del <label>{eje:graf2}.} <meta>{fig:ejer53} </body>{figure} <p><br>{Solución.} Por las características del
problema, tenemos que los grafos usados serán GDA, ya que no pueden existir ciclos. El orden secuencial que
respete los prerequisitos será un orden topológico del grafo. Aplicando el algoritmo estudiado obtenemos el
resultado de la tabla <label>{tab:ejer54}. Ojo, en este caso </font></a>{Array solución} no indica el array
</font></a>{orden} del algoritmo, sino los nodos que se visitan en cada paso del recorrido topológico.
<body>{table}[!ht] <body>{center} </tr></html>{cap5/ejer54.eps} </body>{center} <form>{Obtención de la ordenación
topológica del grafo de la figura <label>{fig:ejer53}.} <meta>{tab:ejer54} </body>{table} Podemos deducir que
orden obtenido no es único si en algún paso de la ejecución la cola tiene más de un vértice. Para este ejemplo
ocurre en numerosos pasos, como se puede ver en la tabla <label>{tab:ejer54}. Por lo tanto, la ordenación
topológica obtenida no es única. Otra posible ordenación topológica podría ser: 1, 11, 12, 3, 4, 2, 8, 13, 5, 9,
6, 10, 7. <table> <meta>{eje:graf3} En cierto país petrolífero se supone la existencia de armas de destrucción
masiva. La ONU ha decidido planificar una serie de inspecciones exhaustivas, para analizar todos los posibles
almacenes de armas. Tenemos un mapa $T$ de localizaciones, como el mostrado en la figura <label>{fig:ejer55}, con
$n$ sitios sospechosos y los caminos existentes entre ellos. En el mapa, $T[i,j]=T[j,i]$ valdrá 1 si existe un
camino entre $i$ y $j$, y 0 en caso contrario. Existen varios equipos de inspectores, que parten inicialmente del
mismo sitio. Cada equipo visita un sitio durante un día y se desplaza por la tarde (es decir, en todos los caminos
tardamos un tiempo unitario). <body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejer55.eps} </body>{center}
<form>{Mapa de localizaciones sospechosas del ejercicio <label>{eje:graf3}.} <meta>{fig:ejer55} </body>{figure}
<title>Cuestiones de autoevaluación} <table> Indicar cuál es el número máximo de arcos que puede tener: a) un
grafo no dirigido, b) un grafo dirigido, c) un grafo no dirigido sin ciclos, d) un grafo dirigido acíclico (GDA).
</table> <table> Dado un árbol de expansión resultante de un recorrido sobre un grafo no dirigido, ¿qué tipo de
arcos (aparte de los del árbol) pueden aparecer si el recorrido es una búsqueda en profundidad o una búsqueda en
anchura? ¿Qué arcos aparecerán si el recorrido (en profundidad o en anchura) es aplicado sobre un grafo dirigido?
Por ejemplo, demostrar que en un bosque de expansión en profundidad de un grafo dirigido, todos los arcos de cruce
van de derecha a izquierda. </table> <table> El árbol de expansión en profundidad o en anchura de un grafo ¿es
único o existen varias posibilidades? ¿En función de qué surgen las distintas posibilidades? </table> Hay que
tener en cuenta que las armas se pueden mover de sitio, para evitar ser descubiertas. Las armas se mueven por los
mismos caminos que los inspectores, aunque lo hacen por la noche (es decir, no se pueden cruzar por el camino).
Para garantizar que el plan de inspecciones sea efectivo debemos garantizar lo siguiente: 1) todos los sitios son
inspeccionados, 2) hay que evitar que se puedan mover armas a un sitio que ya ha sido inspeccionado; para ello,
debemos garantizar que cualquier posible camino entre un sitio inspeccionado y uno no inspeccionado pase por un
sitio que esté siendo inspeccionado. Diseñar dos algoritmos para resolver los siguientes problemas: <li> </font>
[a)] Suponiendo que todos los equipos de inspectores parte del sitio $I$, encontrar cuánto tiempo tardaría el plan
de inspecciones como mínimo, qué sitios se deben visitar cada día, cuántos equipos de inspectores necesitamos en
total y por dónde se debe mover cada equipo. Ejecutar sobre el grafo de la figura <label>{fig:ejer55} con $I = 1$.
</font> [b)] Suponiendo que queremos minimizar el tiempo total del plan de inspecciones, encontrar desde qué sitio
deben partir las inspecciones, qué sitios se deben visitar cada día y cuántos equipos de inspectores necesitamos.
</li> </table> <p><br>{Solución.} Vamos a dar algunas indicaciones para la resolución de estos problemas, pero sin
llegar a escribir los algoritmos. El problema a) se puede plantear de distintas maneras. Por ejemplo, si usamos
una búsqueda primero en anchura, el primer día inspeccionamos la raíz del árbol, el segundo día los nodos que
están un nivel debajo de la raíz, el tercero los nodos que están a nivel 3, y así sucesivamente. El tiempo que se
tarda en el plan sería igual a la profundidad máxima del árbol. Los sitios que visitan cada día $i$ serían los
nodos de nivel $i$. El número de inspectores que se necesitan son el número de hojas del árbol abarcador en
anchura. Y los movimientos de cada equipo de inspectores son los caminos desde la raíz hasta esa hoja. Por
ejemplo, en el grafo de la figura <label>{fig:ejer55} se tardaría 4 días. El día 1 se visita el nodo 1, el día 2
los nodos 7 y 5, el día 3 los nodos 2, 3 y 4, y el día 4 el nodo 6. El problema también se puede plantear como un
problema de caminos mínimos, donde todas las aristas tienen coste 1. Si calculamos el camino mínimo desde el nodo
inicial $I$ hasta todos los demás (por ejemplo, con el algoritmo de Dijkstra), el primer día deberíamos visitar la
raíz, el segundo los nodos que están a distancia 1, el tercero todos los que están a distancia 2, y así
sucesivamente. El tiempo total que se tardaría sería la distancia máxima de los caminos mínimos, más 1. El número
de inspectores sería loyd. Después tomamos máximos por filas (o por columnas, en este caso es equivalente) de la
matriz de caminos mínimos, y nos quedamos con el nodo con menor valor máximo. El número de inspectores que se
necesitan un día $k$ son los nodos que estén a distancia $k-1$ del nodo central. Una posible cota inferior para el
número de inspectores necesario es el máximo número de inspectores que se necesitan para todos los días. <table>
<meta>{eje:graf4} La experimentación con ratones es básica para crear nuevos fármacos, que resultan en importantes
mejoras en la calidad de vida de los roedores. En un experimento con fármacos cerebrales, se colocan ratones
dentro de un laberinto formado por $n$ celdas, $m$ salidas del laberinto y varios pasadizos entre las celdas o las
salidas, como el mostrado en la figura <label>{fig:ejer56}. Las celdas son numeradas de 1 a $n$ y las salidas de
$n+1$ a $n+m$. En cada pasadizo los ratones tardan un tiempo dado, que llamaremos $P[i, j]$: tiempo de ir de la
celda $i$ a la celda o salida $j$. Se supone que el tiempo que tardan en las celdas es despreciable. El
experimento consiste en colocar inicialmente un ratón en cada celda, y contar el número de ratones que son capaces
de salir del laberinto en un tiempo dado $t_{max}$. Suponiendo que los ratones eligen siempre el camino más corto
hacia alguna de las salidas, las preguntas a resolver son: i) ¿Cuántos ratones habrán salido en el instante dado
$t_{max}$? ii) ¿Cuánto tiempo se necesita para conseguir que todos los ratones hayan salido? el número de nodos
que no aparecen como nodos intermedios de algún camino mínimo. Esta solución garantiza las restricciones del
problema: si estamos en un día $k$ cualquiera, para pasar de un nodo no inspeccionado (con distancia mínima mayor
que $k$) a uno ya inspeccionado (con distancia mínima menor que $k$) se debe pasar por alguno que esté siendo
inspeccionado (con distancia mínima $k$). Según lo anterior, para resolver el problema b) simplemente deberíamos
calcular para cada nodo la distancia máxima de los caminos mínimos desde ese nodo hasta todos los demás. Esto es
lo que se conoce como la <br>{excentricidad} de un nodo en un grafo. Las inspecciones deben comenzar desde el nodo
más central, es decir el que tenga excentricidad mínima. La solución se puede programar fácilmente usando el
algoritmo de F <body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejer56.eps} </body>{center} <form>{Laberinto
del ejercicio <label>{eje:graf4}.} <meta>{fig:ejer56} </body>{figure} Diseñar un algoritmo para resolver los dos
problemas anteriores. Se supone que el instante inicial es $t= 1$. Hacer una estimación aproximada del orden de
complejidad del algoritmo. </table> <p><br>{Solución.} Claramente, el ejercicio es un problema de caminos mínimos
en un grafo. Se puede resolver fácilmente con el algoritmo de Dijkstra. El valor de i) será el número de celdas
para las cuales la distancia mínima a alguna de las salidas sea menor o igual que $t_{max}$. El valor de ii) será
el máximo de las distancias mínimas de cada celda a alguna de las salidas. Para simplificar la implementación,
utilizaremos el algoritmo de Floyd, calculando todos los caminos mínimos entre todas las celdas y salidas. El
algoritmo sería el siguiente. <body>{especi} <br>{operación} Ratones (</br>{n}, </br>{m}, </br>{tmax}: entero;
</br>{P}: <br>{array} [1..</br>{n}+</br>{m}, 1..</br>{n}+</br>{m}] <br>{de} entero; <br>{var}
</br>{RatonesQueSalen}, </br>{MaximoTotal}: entero) <br>{variables} </br>{C}: <br>{array} [1..</br>{n}+</br>{m},
1..</br>{n}+</br>{m}] <br>{de} entero <body>{in1} </br>{C}:= </br>{P} <br>{para} </br>{k}:= 1, ...,
</br>{n}+</br>{m} <br>{hacer} <body>{in1} <br>{para} </br>{i}:= 1, ..., </br>{n}+</br>{m} <br>{hacer} <body>{in1}
<br>{para} </br>{j}:= 1, ..., </br>{n}+</br>{m} <br>{hacer} <body>{in1} </br>{C}[</br>{i}, </br>{j}]:=
min(</br>{C}[</br>{i}, </br>{j}], </br>{C}[</br>{i}, </br>{k}]+</br>{C}[</br>{k}, </br>{j}]) </body>{in1}
<br>{finpara} </body>{in1} <br>{finpara} </body>{in1} <br>{finpara} </br>{MaximoTotal}:= 0 <br>{para} </br>{i}:=
1, ..., </br>{n} <br>{hacer} <body>{in1} </br>{TiempoMinimo}:= </br>{C}[</br>{i}, </br>{n}+1] <br>{para}
</br>{j}:= </br>{n}+2, ..., </br>{n}+</br>{m} <br>{hacer} </br>{MaximoTotal}:= max(</br>{MaximoTotal},
</br>{TiempoMinimo}) </body>{in1} <br>{finpara} </body>{in1} </body>{especi} Para el laberinto de la figura
<label>{fig:ejer56} tenemos el resultado final: </font></a>{Rato\-nes\-Que\-Salen= 4},
</font></a>{Maxi\-mo\-To\-tal= 7}. Se puede ver fácilmente que el tiempo del algoritmo pertenece a
$\Theta((n+m)^3)$. <title>Ejercicios propuestos} <table> Implementar la prueba de aciclicidad en un grafo no
dirigido de manera eficiente. ¿Se puede conseguir en un tiempo $O(n)$? Modificar el procedimiento para que, en
caso de encontrar que existe un ciclo, devuelva en una lista o en un array los elementos que forman el ciclo
encontrado. </table> <table> <meta>{eje:graf5} Suponer el grafo no dirigido de siguiente figura
<label>{fig:ejer57}. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejer57.eps} </body>{center} <form>{Grafo
no dirigido del ejercicio <label>{eje:graf5}.} <meta>{fig:ejer57} </body>{figure} Se pide resolver las siguiente
cuestiones sobre el mismo: <li> </font> [a)] El bosque de expansión en profundidad, empezando en \textsf{a} y en
\textsf{d}. </font> [b)] El bosque de expansión en amplitud, empezando en \textsf{a} y en \textsf{d}. </font> [c)]
El árbol de expansión de coste mínimo utilizando el algoritmo de Prim. </font> [d)] El árbol de expansión de coste
mínimo utilizando el algoritmo de Kruskal. ¿Son iguales las soluciones obtenidas en ambos algoritmos? En caso
contrario, ¿son válidas las distintas soluciones? ¿Por qué? </font> [e)] Encontrar los puntos de articulación y
los componentes biconexos. ¿Cuál es la conectividad del grafo? </li> </table> <table> Demostrar que el algoritmo
de Dijkstra no funciona cuando las aristas pueden tener coste negativo, aun cuando no existan ciclos en el grafo.
Sugerencia: dar un contraejemplo de un grafo dirigido sin ciclos en el que el algoritmo de Dijkstra no encuentre
el resultado correcto. </table> <table> Modificar el algoritmo de Dijkstra para que, además de calcular los
caminos mínimos del vértice origen al resto, también calcule los siguientes valores: <li> </font> Un array
</font></a>{</br>{L}} de tamaño $n$, indicando el número de aristas por las que pasa cada uno de los caminos
mínimos. En caso de empate de coste en los caminos mínimos, el algoritmo deberá quedarse con el camino que pase
por menos aristas. </font> Un array </font></a>{</br>{U}} de booleanos, en el que se indique para cada nodo si su
camino mínimo desde el origen es único o no. </li> </table> <table> <meta>{eje:graf6} Considerar el grafo dirigido
de la figura <label>{fig:ejer58}. Resolver las siguientes cuestiones: <li> </font> [a)] Aplicar el algoritmo de
Dijkstra para encontrar los caminos más cortos que van desde el nodo </font></a>{a} hasta los restantes nodos.
Mostrar los valores </font></a>{</br>{T}}, </font></a>{</br>{D}} y </font></a>{</br>{P}} para todos los pasos de
ejecución del algoritmo. </font> [b)] Utilizando el resultado del apartado anterior, encontrar la secuencia de
nodos del camino mínimo de </font></a>{a} a </font></a>{d}, y el de </font></a>{a} a </font></a>{e}. </font> [c)]
Aplicar el algoritmo de obtención de los componentes fuertemente conexos. A partir del resultado obtenido, mostrar
el grafo reducido correspondiente. </font> [d)] Mostrar el resultado de la aplicación del algoritmo de Floyd.
Obtener el nodo centro del grafo. </li> </table> <body>{figure}[!ht] <body>{center} </tr></html>{cap5/ejer58.eps}
</body>{center} <form>{Grafo dirigido del ejercicio <label>{eje:graf6}.} <meta>{fig:ejer58} </body>{figure}
<table> Diseñar un algoritmo para contar el número de ciclos simples existentes en un grafo no dirigido. ¿Cuál es
el orden de complejidad de este algoritmo? ¿Cuántos ciclos pueden haber como máximo en un grafo cualquiera?
</table> T Conjunto de posibles etiquetas de las aristas N Conjunto de naturales <table> Proporcionar un algoritmo
con tiempo $O(n+a)$ para comprobar si un grafo es bipartido o no. Aplicarlo sobre los grafos de las figuras
<label>{fig:ejer57} y <label>{fig:ejer59}. Sugerencia: utilizar la búsqueda primero en profundidad. </table>
<table> <meta>{eje:graf7} Aplicar el algoritmo de Kruskal sobre el grafo de la figura <label>{fig:ejer59},
mostrando el orden en que son añadidas las aristas a la solución. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/ejer59.eps} </body>{center} <form>{Grafo no dirigido con pesos del ejercicio
<label>{eje:graf7}.} <meta>{fig:ejer59} </body>{figure} Si aplicáramos el algoritmo de Prim, ¿podemos asegurar que
se obtendría siempre la misma solución? ¿Podemos asegurar que el coste de la solución sería el mismo? ¿Por qué?
Comprobar las respuestas mostrando la ejecución del algoritmo de Prim sobre el mismo grafo. </table> <table> Para
desarrollar la especificación formal del TAD </font></a>{GrafoNDE[T]}, de los grafos no dirigidos y etiquetados
con etiquetas de tipo </font></a>{T}, disponemos de los siguientes conjuntos: <body>{especi} <body>{in1} G
Conjunto de grafos dirigidos con pesos V Conjunto de vértices B Conjunto de booleanos U Conjunto de mensajes de
error \{``Vértice no existente'', ``Arista no existente''\} </body>{in1} </body>{especi} No se define el conjunto
de aristas puesto que es implícito (una arista es un par de vértices más una etiqueta). Escribir la sintaxis y la
semántica de la especificación algebraica del tipo, incluyendo al menos las siguientes operaciones:
</font></a>{GrafoVacío}, </font></a>{InsertaNodo}, </font></a>{InsertaArista}, </font></a>{ExisteArista},
</font></a>{EtiquetaArista} (para consultar la etiqueta de una arista), </font></a>{NumNodos},
</font></a>{NumAristas}, </font></a>{BorraArista}. </table> <table> Se define el radio de un árbol como la
distancia máxima de la raíz a cualquiera de los nodos hoja. Dado un grafo no dirigido y conexo, escribir un
algoritmo para encontrar un árbol de expansión de radio mínimo. </table> <table> Construir un algoritmo para
evaluar expresiones aritméticas representadas mediante GDA. Suponer que tenemos almacenada una etiqueta para cada
nodo del grafo </font></a>{</br>{ETIQ}}[1..$n$] con los valores (+, -, *, A, B, ..., Z). Especifica la estructura
de representación del grafo que consideres más oportuna, con las operaciones adecuadas. Los valores para las
variables son obtenidos llamando a un función </font></a>{ValorVariable (car: caracter): real}. Sugerencia:
Almacenar el valor de cada nodo en un array </font></a>{</br>{VALOR}}[1..$n$] de reales. </table> <table> Un pozo
en un grafo dirigido es un vértice al cual llegan aristas de todos los vértices restantes pero del cual no parte
ninguna arista. Escribir un algoritmo que determine la existencia de pozos y, en su caso, obtenga cuáles son en un
orden $O(n)$. </table> <table> <meta>{eje:graf8} Suponer el grafo dirigido acíclico de la figura
<label>{fig:ejer510}. Resolver las siguientes cuestiones sobre el mismo: <html>{figure}[!ht] <html>{center}
</tr></html>{cap5/ejer510.eps} </html>{center} <form>{Grafo dirigido acíclico con pesos del ejercicio
<label>{eje:graf8}.} <meta>{fig:ejer510} </html>{figure} <li> </font> [a)] Encontrar una ordenación topológica del
grafo. Mostrar los pasos de ejecución del algoritmo. ¿Es única esta ordenación o existen otras ordenaciones
válidas? </font> [b)] Aplicar el algoritmo de flujo máximo, obteniendo el grafo $G_F$ de flujos resultantes.
Aplicar el algoritmo que permite deshacer caminos. ¿Cuánto vale el flujo máximo total? </font> [c)] Encontrar los
componentes fuertemente conexos del grafo. A partir de ellos mostrar el grafo reducido correspondiente. A la vista
del resultado, ¿podemos establecer alguna relación general entre un GDA y su grafo reducido? ¿Cuál? ¿Por qué?
</li> </table> <table> En un problema de planificación de tareas utilizamos GDA, donde los nodos contienen tareas
a realizar y las aristas indican la precedencia de tareas. Las aristas son etiquetadas con un coste, que indica el
tiempo necesario para acabar la tarea que es cabeza de la arista.ejemplo <label>{eje:puntarticul}.}
<meta>{fig:articul4} </body>{figure} <html>{Circuitos de Euler} Los problemas de circuitos de Euler aparecen
cuando se utilizan grafos para representar dibujos de líneas. En la figura <label>{fig:euler1} se muestran tres de
estos ejemplos. En estos grafos, cada nodo representa un punto del dibujo y una arista entre dos nodos indica que
existe una línea entre los dos puntos correspondientes. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/euler1.eps} </body>{center} <form>{Circuitos y caminos de Euler. Arriba: dibujo de líneas.
Abajo: grafo correspondiente. a) Tiene un circuito de Euler. b) Tiene un camino de Euler. c) No tiene circuito ni
camino de Euler.} <meta>{fig:euler1} </body>{figure} El problema del circuito de Euler trata de responder a la
cuestión: ¿es posible dibujar la figura con un bolígrafo, pintando cada línea una sola vez, sin levantar el
bolígrafo y acabando en el mismo punto donde se empezó? Formulado con terminología de grafos, decimos que un
<br>{circuito de Euler} es un ciclo, no necesariamente simple, que visita todas las aristas exactamente una vez.
Es decir, los nodos se pueden visitar varias veces, pero las aristas se tienen que visitar una y solo una vez. Así
que dado un grafo, tenemos que decidir si existe un circuito de Euler. Hay claramente dos condiciones necesarias
para que exista un circuito de Euler: <li> </font> El grafo debe ser conexo. </font> El grado de todos los nodos
--es decir, número de aristas incidentes-- debe ser par. La razón es que si el camino pasa varias veces por un
nodo, siempre que entra por una arista debe salir por otra. </li> Un concepto relacionado con el circuito de Euler
es el de camino de Euler. Un <br>{camino de Euler} es un camino que visita todas las aristas exactamente una vez,
pudiendo empezar y acabar en sitios distintos. Las condiciones necesarias para que exista, en este caso, serían
similares a las del circuito de Euler. La segunda condición primer tipo, tenemos una vía alternativa. El algoritmo
se basa en el cálculo de los caminos alternativos. Se realiza una búsqueda primero en profundidad, numerando los
nodos en el orden de recorrido. Al mismo tiempo se calculan los ``caminos alternativos''. El resultado se guarda
en un array </font></a>{<font_arial>{bajo}: <br>{array} [1..<font_arial>{n}] <br>{de} entero}. El valor de
</font></a>{<font_arial>{bajo}} de un nodo </font></a>{<font_arial>{v}} indica lo más arriba que podemos llegar en
el árbol a través de un camino alternativo. El camino alternativo para un nodo permitiría que existan dos nodos
con grado impar, o ninguno. Los demás deberían tener grado par. Se puede comprobar que las anteriores condiciones
necesarias son también suficientes. Esto es, si se cumplen entonces existe un circuito de Euler. El objetivo ahora
es encontrar un algoritmo para encontrar el circuito o camino de Euler. &nbsp; {Algoritmo para calcular un
circuito de Euler} Supongamos un grafo no dirigido $G$. En primer lugar deberíamos comprobar si se cumplen las
condiciones necesarias y suficientes. En ese caso, tenemos garantizado que existe un circuito de Euler, y podemos
encontrarlo con el siguiente algoritmo: <body>{enumerate} </font> Unir el ciclo del paso 1 con el obtenido en el
paso 2. Repetir sucesivamente los pasos 2 y 3 hasta que no queden aristas por visitar. </body>{enumerate} Para
encontrar un ciclo, en los pasos 1 y 2, podemos utilizar una búsqueda primero en profundidad, como se comenta en
el apartado <label>{sec:grafosbpp}. No obstante, la una solución eficiente para los mismos resultaría deseable.
Sin embargo, existe una amplia variedad de problemas para los cuales no se conoce hasta la fecha ningún algoritmo
capaz de resolverlos de forma eficiente --a pesar de los numerosos años de esfuerzo dedicados y del fenomenal
avance que supondría encontrarlos. Entendemos complejidad del algoritmo viene dado por el orden de la búsqueda
primero en profundidad: $O(n^2)$ con matrices de adyacencia y $O(n+a)$ con listas de adyacencia. <body>{ejemplo}
<meta>{eje:puntarticul} En la figura <label>{fig:articul3} se muestra un ejemplo de aquí por eficiente un
algoritmo con tiempos polinomiales, del tipo $O(n)$, $O(n^2)$, $O(n^{32})$, etc. Esta categoría de problemas para
los cuales no se conocen soluciones eficientes --ya sean sobre grafos o no-- son conocidos como <br>{problemas
NP}. Los algoritmos existentes para resolver problemas de este tipo se basan, en esencia, en comprobar todas las
posibles soluciones de manera exhaustiva, dando lugar a tiempos exponenciales o factoriales.
</tr></html>{cap5/hamilton.eps} </body>{center} El resultado es lo que se conoce como el efecto de <br>{explosión
combinatoria}, que hace referencia a la forma en la que se dispara el tiempo de ejecución para tamaños grandes del
problema. Alternativamente, se pueden diseñar algoritmos que obtengan soluciones más o menos </label>{buenas}, no
necesariamente la óptima, pero en un tiempo reducido. Estos son conocidos como <br>{algoritmos heurísticos}. Vamos
a ver un conjunto de problemas clásicos sobre grafos, que están dentro de la categoría NP. En este apartado
únicamente enunciaremos el problema, mostrando las posibles aplicaciones prácticas donde puede ser de utilidad.
Por el momento, no daremos algoritmos para resolverlos. Conforme se avance hacia los capítulos de diseño de
algoritmos, sería adecuado intentar plantearse la resolución de estos problemas con las técnicas que se vayan
estudiando. <html>{Ciclos hamiltonianos} <body>{figure}[!ht] <body>{center} En principio, el problema del ciclo
hamiltoniano tiene una formulación muy similar a la del circuito de Euler. Veamos la definición.
<body>{definicion} Dado un grafo no dirigido $G$, se llama <br>{ciclo de Hamilton} o <br>{ciclo hamiltoniano} a un
ciclo simple que visita todos los vértices. </body>{definicion} Es decir, el ciclo hamiltoniano pasa por todos los
vértices exactamente una vez. El <br>{problema del ciclo hamiltoniano} consiste en: dado un grafo no dirigido $G$,
determinar si posee algún ciclo hamiltoniano. Por ejemplo, en el grafo de la figura <label>{fig:hamilton}a) existe
un ciclo de Hamilton, que ha sido señalado con línea más gruesa. El de la figura <label>{fig:hamilton}b) no posee
ningún ciclo hamiltoniano, lo cual ha sido verificado comprobando exhaustivamente todos los posibles caminos. El
de la figura <label>{fig:hamilton}c) se deja como pasatiempo. <form>{Problema del ciclo hamiltoniano. a) Grafo con
un ciclo hamiltoniano. b) Grafo que no posee ningún ciclo de Hamilton. c) ¿Existe algún ciclo hamiltoniano?}
<meta>{fig:hamilton} </body>{figure} Aunque parece similar al del circuito de Euler, la complejidad implícita del
problema del ciclo de Hamilton resulta muchísimo mayor. Mientras que el circuito de Euler se puede resolver
aplicando varias búsquedas que no exista.}. Se encuentra dentro de los problemas NP. La solución para este
problema consistiría en encontrar todos los posibles caminos simples, comprobando si alguno de ellos es un ciclo
hamiltoniano. Si el grafo es completo, el número de caminos simples distintos sería un $(n-1)!$. Para reducir el
tiempo, podemos diseñar algún algoritmo heurístico. Por ejemplo, podemos aplicar una búsqueda en profundidad en la
cual en profundidad, para el ciclo de Hamilton no se conoce ningún algoritmo capaz de resolverlo en un tiempo
polinomial</a>{Lo cual, como veremos en el último capítulo, no quiere decir de todos los adyacentes a un nodo se
visitan primero los que tengan menor grado. Si lo aplicamos sobre el grafo de la figura <label>{fig:hamilton}a),
encontramos la solución. Empezando por el 1, nos vamos al 5 (grado 3), luego al 2, 3, 7, 6, 4 y cerramos el ciclo.
Pero este algoritmo no siempre garantiza la solución. Y si no la encuentra puede que exista o puede que no, como
ocurre con el grafo de la figura <label>{fig:hamilton}c). <html>{Problema del viajante} El <br>{problema del
viajante}, también conocido como <br>{problema del agente viajero}, es uno de los más recurridos en las
aplicaciones que utilizan grafos para representar caminos con costes asociados</a>{Además de los problemas de
caminos mínimos vistos en el apartado <label>{sec:caminosminimos}, claro.}. La formulación del problema es la
siguiente: dado un grafo no dirigido, completo y con pesos, $G$, encontrar el ciclo simple de coste mínimo que
recorra todos los nodos. El ciclo al que se refiere el problema sería un ciclo hamiltoniano. Pero la dificultad
ahora no está en determinar si existe o no ese ciclo --ya que, al ser completo, trivialmente se sabe que existirá
siempre-- sino en encontrar el que tenga menor coste de todos ellos. En la figura <label>{fig:viajante}a) se
muestra un grafo de ejemplo, y en la <label>{fig:viajante}b) se muestra una posible solución. ¿Es la solución
óptima? <body>{figure}[!ht] <body>{center} </tr></html>{cap5/viajante.eps} </body>{center} <form>{Problema del
viajante. a) Grafo no dirigido completo y con pesos. b) Posible solución al problema.} <meta>{fig:viajante}
</body>{figure} Las aristas del grafo pueden tener coste $+ </blockquote>fty$. Así que decir que el grafo debe ser
completo es sólo una forma de interpretar los datos: si el grafo no es completo, las aristas faltantes son
consideradas con coste $+ </blockquote>fty$. <body>{ejemplo} El problema del viajante está subyacente en
aplicaciones de tipo ``reparto de mercancías''. Por ejemplo, un camionero distribuye pimientos murcianos por toda
la región. vértices de $V(G)$ con los vértices de $V(F)$ tal que se respetan las aristas. Es decir, es una función
biyectiva: $f: V(G) <symbol> V(F)$, tal que para todo $v,w </blockquote> V(G)$, $(v,w) </blockquote> A(G)
\Leftrightarrow (f(v),f(w)) </blockquote> A(F)$. </body>{definicion} Dos grafos se dice que son <br>{isomorfos} si
existe un isomorfismo entre ellos. Por ejemplo, entre los grafos de la figura <label>{fig:isomorfo1} existen
varios posibles isomorfismos. Uno de ello podría ser la asignación: $1<symbol> b;~ 2 <symbol> a;~ 3 Tiene que
pasar por varios supermercados, $n$, pero el orden le es indiferente. Eso sí, el catécnicas heurísticas para
abordar este problema, como algoritmos voraces, búsqueda local, algoritmos genéticos e incluso computación con
ADN. Pero ninguno de ellos garantiza que se mión debe volver al mismo sitio de donde salió. Cada camino necesita
un tiempo determinado. El objetivo es planificar la ruta que tiene que seguir, de forma que el tiempo total sea el
menor. La equivalencia con el problema del viajante es inmediata: los $n$ supermercados son los nodos del grafo;
los caminos son las aristas, siendo el tiempo el peso de las mismas; y el objetivo buscado es el menor ciclo
simple que visita todos los nodos. </body>{ejemplo} Teniendo en cuenta que existen $(n-1)!$ posibles ciclos
simples, un algoritmo óptimo sencillo estaría en un orden de complejidad factorial. Se han desarrollado numerosas
e obtenga el óptimo, o que la solución obtenida sea próxima a la óptima. Igual que para el problema del ciclo
hamiltoniano, no se conoce ningún algoritmo eficiente que lo resuelva de forma óptima. Es más, se puede demostrar
que ambos problemas son equivalentes. La equivalencia se obtiene viendo que es posible transformar un problema en
el otro y viceversa. Por ejemplo, para resolver el problema del ciclo hamiltoniano en un grafo no dirigido
$G=(V,A)$, podemos considerar el grafo $G'=(V,A',W)$, donde $A'$ contiene todas las aristas posibles, y $W(v,w)=1$
si la arista $(v,w) </blockquote> A$ y $W(v,w)=+ </blockquote>fty$ en caso contrario. Si resolvemos el problema
del viajante en $G'$, entonces existirá un ciclo hamiltoniano siempre que el coste sea menor que $+
</blockquote>fty$. <html>{Coloración de grafos} En los problemas de coloración de grafos, las aristas no
representan </label>{caminos} sino </label>{incompatibilidades}. Los nodos representan cierto tipo de objeto y
existe una arista $(v,w)$ entre dos nodos si los objetos $v$ y $w$ son incompatibles. La coloración de un grafo
consiste en asignar un <br>{color} o <br>{etiqueta} a cada nodo, de forma que dos nodos incompatibles no tengan el
mismo color. Formalmente se puede definir de la siguiente manera. <body>{definicion} Dado un grafo $G=(V,A)$ no
dirigido, una <br>{coloración del grafo} es una función $C: V <symbol> N$, tal que si $(v,w) </blockquote> A$
entonces $C(v) \neq C(w)$. </body>{definicion} El <br>{problema de la coloración} de grafos consiste en: dado un
grafo no dirigido, encontrar una coloración del mismo utilizando el mínimo número de colores distintos. En la
figura <label>{fig:colores} se muestra un ejemplo del problema. Las figuras hasta llegar al problema original. La
memoria ocupada por la tabla se convierte en uno de los factores críticos de los algoritmos de programación
dinámica. Para obtener la descomposición recursiva, el problema se puede interpretar como una serie de toma de
decisiones. Después de cada decisión, nos queda un problema de menor tamaño. <body>{figure}[!ht] <body>{center}
</tr></html>{cap5/colores.eps} </body>{center} <form>{Problema de coloración de grafos. a) Grafo no dirigido del
problema. b) Coloración usando 5 colores. c) Coloración usando 3 colores.} <meta>{fig:colores} </body>{figure} El
problema de coloración de grafos es también un problema NP. La solución consistiría en comprobar todas las
posibles coloraciones y quedarnos con la que use menos colores. <body>{ejemplo} En un mapa geopolítico aparecen
dibujadas distintas regiones, cada una de las cuales es fronteriza con otras regiones. Queremos rellenar de color
las regiones del mapa, de forma que dos regiones fronterizas no tengan el mismo color. Para ahorrar costes de
producción, la editorial pide que se use el mínimo número de colores distintos. ¿Cuántos colores diferentes
necesitamos, como mínimo, para colorear el mapa? El problema puede ser modelado usando grafos. Cada región del
mapa se corresponderá con un nodo del grafo. Habrá una arista entre dos nodos si las regiones asociadas son
fronterizas. En la figura <label>{fig:colores2} aparece un ejemplo de transformación de un problema de mapas a un
problema de grafos. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/colores2.eps} </body>{center}
<form>{Problema de coloración de un mapa. a) Mapa de la Tierra Media. b) Transformación a un problema de grafos.}
<meta>{fig:colores2} </body>{figure} Está claro que el resultado del problema será la coloración mínima del grafo.
Los grafos que surgen en este tipo de aplicación son llamados <br>{grafos planos}. Un grafo se dice que es plano
si se puede dibujar en papel sin que se crucen las aristas. Está demostrado que cualquier grafo plano puede
dibujarse usando como máximo cuatro colores. Pero para los grafos no planos el número de colores depende del caso.
</body>{ejemplo} <html>{Isomorfismo de grafos} El isomorfismo de grafos es una </label>{generalización} de la
igualdad entre dos grafos. Por definición, dados dos grafos $G$ y $F$, se dice que son iguales cuando $V(G)=V(F)$
y $A(G)=A(F)$. Pero lo que normalmente interesa no es la comparación de grafos en igualdad, sino conocer si los
grafos tienen una estructura </label>{equivalente}. Esto es lo que llamamos isomorfismo. <body>{definicion} Dados
dos grafos $G$ y $F$, un <br>{isomorfismo entre grafos} es una asignación de los <symbol> d;~ 4 <symbol> e;~ 5
<symbol> c;~ 6 <symbol> g;~ 7 <symbol> f$. <body>{figure}[!ht] <body>{center} </tr></html>{cap5/isomorfo1.eps}
</body>{center} <form>{Problema del isomorfismo de grafos. a),b) Dos grafos no dirigidos isomorfos.}
<meta>{fig:isomorfo1} </body>{figure} Nuevamente, el isomorfismo de grafos es un problema NP. La solución
consistiría en ir comprobando todas las posibles asignaciones, hasta encontrar alguna válida. Esto requeriría un
orden de tipo factorial. Si el grafo es etiquetado, entonces la asignación debería respetar también los pesos o
etiquetas de las aristas. En ciertas aplicaciones, puede surgir el problema del <br>{subisomorfismo} de grafos.
Intuitivamente, el subisomorfismo es la mayor asignación posible entre los nodos de los dos grafos, que
</label>{respete} las aristas. Vamos a ver un ejemplo. <body>{ejemplo} Una aplicación de visión artificial analiza
una imagen y debe interpretar qué es lo que está viendo. Su mundo se reduce a un conjunto de $p$ poliedros, de
cada uno de los cuales posee un modelo. Existen dos nodos destacados, <a_href="nn.html">{Inicio} y
<a_href="nn.html">{Fin}, para indicar el principio y el final del plan, respectivamente. Puesto que todas las
tareas se deben realizar necesariamente para acabar el plan, el problema fundamental consiste en calcular la
longitud del camino más largo entre </br>{Inicio} y <a_href="nn.html">{Fin}, que será el tiempo mínimo en ejecutar
el plan. <li> </font> [a)] Comprobar que una simple modificación del algoritmo de Dijkstra (buscando máximos en
lugar de mínimos) no resuelve el problema de calcular el camino más largo entre dos nodos. </font> [b)] Proponer
un  Sugerencia: tener en cuenta el orden topológico. </font> [c)] Aplicar el algoritmo diseñado sobre el grafo de
la figura <label>{fig:ejer510}. </li> </table> <table> Implementar el algoritmo para la búsqueda de puntos de
articulación en un grafo no dirigido, modificando las partes adecuadas del procedimiento </font></a>{bpp} de la
búsqueda primero en profundidad. ¿Cuál es el orden de complejidad del algoritmo? </table> <table> ¿Cómo se podría
modificar el procedimiento </font></a>{bpa} --utilizado en la búsqueda primero en anchura-- para realizar un
recorrido en profundidad, realizando un cambio mínimo en el algoritmo? Sugerencia: considera la estructura de
datos utilizada. </table> <table> ¿Cuántos árboles de expansión tiene un grafo no dirigido completo de $n$ nodos?
</table> </html> algoritmo para calcular la longitud del camino más largo entre los nodos
<a_href="nn.html">{Inicio} y <a_href="nn.html">{Fin}, teniendo en cuenta que trabajamos con GDA. ¿Cuál es el orden
de complejidad del algoritmo?
